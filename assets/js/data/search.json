[ { "title": "iOS View", "url": "/posts/view/", "categories": "Notes", "tags": "swift, view, layout", "date": "2022-02-13 13:41:10 +0400", "snippet": "LifecycleLifecycle of a UIViewController: loadViewCreates the view that the controller manages. It’s only called when the view controller is created and only when done programatically. It is responsible for making the view property exist in the first place. viewDidLoadCalled after the controller’s view is loaded into memory. It’s only called when the view is created. viewWillAppearIt’s called whenever the view is presented on the screen. In this step the view has bounds defined but the orientation is not applied. viewWillLayoutSubviewsCalled to notify the view controller that its view is about to layout its subviews. This method is called every time the frame changes viewDidLayoutSubviewsCalled to notify the view controller that its view has just laid out its subviews. Make additional changes here after the view lays out its subviews. viewDidAppearNotifies the view controller that its view was added to a view hierarchy. viewWillDisappearBefore the transition to the next view controller happens and the origin view controller gets removed from screen, this method gets called. viewDidDisappearAfter a view controller gets removed from the screen, this method gets called. You usually override this method to stop tasks that are should not run while a view controller is not on screen. viewWillTransition(to:with:)When the interface orientation changes, UIKit calls this method on the window’s root view controller before the size changes are about to be made. The root view controller then notifies its child view controllers, propagating the message throughout the view controller hierarchy.LayoutsetNeedsLayout() The method setNeedsLayout() for a UIView tells the system that you want it to layout and redraw that view and all of its subviews, when it is time for the update cycle. This is an asynchronous activity, because the method completes and returns immediately, but it isn’t until some later time that the layout and redraw actually happens, and you don’t know when that update cycle will be triggered. Apple doc says: Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.layoutIfNeeded()In contrast, the method layoutIfNeeded() is a synchronous call that tells the system you want a layout and redraw of a view and its subviews, and you want it done immediately without waiting for the update cycle. When the call to this method is complete, the layout has already been adjusted and drawn based on all changes that had been noted prior to the method call.layoutSubviews() The default implementation uses any constraints we have set to determine the size and position of any subviews. Subclasses can override this method as needed to perform more precise layout of their subviews. We should override this method only if the auto-resizing and constraint-based behaviors of the subviews do not offer the behavior we want. We can use our implementation to set the frame rectangles on our subviews directly. We should not call this method directly. If you want to force a layout update, we can call the setNeedsLayout() method instead to do so prior to the next drawing update. If we want to update the layout of our views immediately, we can call the layoutIfNeeded() method.updateConstraints It typically doesn’t do anything. It just resolves constraints it doesn’t apply them till layoutSubviews is called. So animation does requires a call to layoutSubviews. setNeedsLayout does not necessary call updateContraints method If our constraints haven’t been modified UIView will skip call to updateConstraints. We need to explicitly call setNeedsUpdateConstraint to modify constraints in the process.Responders UIView is UIResponder type UIViewController is also UIResponder typeThey are the common classes that deals with responding to touches, motion events and etc.FIRST Responder When user tap on a view, the system has to first find out who is the first responder? This is known as a hit-test phase. A hit testing phase starts from the lowest level (the window). Hit test traverse up, while responder chain traverse down. hitTest:withEvent: will be called recursively into subviews (traverse up), until it reaches the leaf view. That responder is the first.Target-ActionThe target-action mechanism also uses the responder chain by setting the target to nil. Then iOS asks the first responder if it handles the action. If not the first responder passes the action to the nextResponder.ConstraintsHugging priority: The one with higher priority hugs its content more and make the other expand more than its intrinsic content. Content hugging priority comes in action when there is lesser content to display, than the available size.Compression resistance It comes into action when content requires more size than the available, when multi-lines. So if we set content compression resistance priority of primary label higher than the secondary label, the secondary label would truncate. And when, content compression resistance priority of primary label is set lower than the secondary label, the primary label would truncate.leftAnchor vs leadingAnchor? Left and Right constraints are absolute, they will always refer to the left/right of the screen or the control. Leading and trailing constraints are affected by the device locale; In locales where the reading direction is left to right (English, French, Spanish and so on) leading &amp;amp; left (and trailing &amp;amp; right) can be used interchangeably. In locales where the reading direction is right to left (e.g Hebrew, Arabic) then ‘leading’ will be the right side and ‘trailing’ will be the left side.Resources: Constraints: https://medium.com/@dineshk1389/content-hugging-and-compression-resistance-in-ios-35a0e8f19118 Hit test: http://smnh.me/hit-testing-in-ios Responder Chain: https://swiftandpainless.com/utilize-the-responder-chain-for-target-action/ https://stackoverflow.com/questions/4961386/event-handling-for-ios-how-hittestwithevent-and-pointinsidewithevent-are-r/4961484#4961484" }, { "title": "Github Action for iOS", "url": "/posts/github-action/", "categories": "Article", "tags": "swift, ci, github", "date": "2021-08-27 13:41:10 +0400", "snippet": "To start with Github Action we need to have a repo and few test written to verify our build and test command.First let’s create a YML file in the directory .github/workflows at the root of your repository.There is a very good post on the YML file hereLet’s look into the a sample github action workflow.Below workflow will build and test a Swift Package Managername: Build My Framework #1on: #2 push: branches: [ main ] pull_request: branches: [ main ]jobs: #3 build: runs-on: macos-latest steps: - uses: actions/checkout@v2 - name: Build run: swift build -v - name: Run tests run: swift test -v The name of the work flow Define when the workflow should get triggered. here it will start either on any commit to main branch or on a pull request. The actions which we want to perform in the work flow. First we choose the operating system which is macos-latest here. Other virtual environments We define the steps or actions in form of name and then run in next line actions/checkout@v2 is a predefined action from github action marketplace. we can use any action from here based on our requirement. Later in the post we have used a 3rd party action from marketplace maxim-lobanov/setup-xcode@v1 from maxim-lobanov. To trigger this work flow we either push a commit to main branch or create a pull request.Select XcodeSelect a specific version of Xcode- name: Show the currently detailed version of Xcode for CLI run: xcode-select -p- name: Select Xcode 12.4 run: sudo xcode-select -s /Applications/Xcode_12.4.app &amp;amp;&amp;amp; xcodebuild -versionSelect the latest Xcode available- uses: maxim-lobanov/setup-xcode@v1 with: xcode-version: latest-stableSelect the latest beta Xcode- uses: maxim-lobanov/setup-xcode@v1 with: xcode-version: latestInstall a specific simulator versionThis process takes some time (around 15 mins) for installing the pkg- name: install simulator run: xcversion simulators --install=&#39;iOS 14.3&#39;Prepare the existing simulator for useSince github action do not load the simulator on its own we need to pre install the main iOS simulators from Xcode runtime to use for xcode build and test.Here is the discussion thread on the same.It is a workaround with symlink simulators to CoreSimulator directory.- name: Prepare iOS 14.4 simulator run: | sudo mkdir -p /Library/Developer/CoreSimulator/Profiles/Runtimes sudo ln -s /Applications/Xcode_12.4.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime /Library/Developer/CoreSimulator/Profiles/Runtimes/iOS\\ 14.4.simruntime xcrun simctl list runtimes xcrun simctl create iPhone_8 &quot;iPhone 8&quot; &quot;com.apple.CoreSimulator.SimRuntime.iOS-14-4&quot; xcrun simctl list devices 14.4Install dependency (if any)Here, we will be installing cocoapods.- name: Install Cocoapods run: gem install cocoapods- name: Install pods to prepare workspace run: pod installPrint current Build settings- name: Show Build Settings run: xcodebuild -workspace Grocery.xcworkspace -scheme Grocery -showBuildSettingsPrint Build SDK- name: Show Build SDK run: xcodebuild -workspace Grocery.xcworkspace -scheme Grocery -showsdksPrint available destinations for workspace/schema- name: Show Available Destinations run: xcodebuild -workspace Grocery.xcworkspace -scheme Grocery -showdestinationsPerform Clean Build- name: clean and build run: xcodebuild clean build -workspace Grocery.xcworkspace -scheme Grocery -destination &#39;platform=iOS Simulator,OS=14.4,name=iPhone 12 mini&#39; -showBuildTimingSummaryPerform Clean Test- name: build and test run: xcodebuild clean test -workspace Grocery.xcworkspace -scheme Grocery -destination &#39;platform=iOS Simulator,OS=14.4,name=iPhone 8&#39; -showBuildTimingSummaryReferences: Github Action setup Apple documentation Github Marketplace" }, { "title": "Swift 5.5 notes", "url": "/posts/swift-5-5/", "categories": "Notes", "tags": "swift", "date": "2021-08-24 13:41:10 +0400", "snippet": "SE-2096 async, awaitThese are the two new keywords in Swift 5.5 for funcs mostly to make them asynchronous and use it like a synchronous function.async and await is to help us avoid pyramid of doom by avoiding completion handler.Ex:func foo() async -&amp;gt; Int { 0 }await foo()When function throwsEx:func foo() async throws -&amp;gt; Int { 0 }try await foo() Synchronous functions can not call asynchronous functions directly, they must use await keyword. async functions can call async functions We can have two functions with same name and only differs with async keyword, Compiler decides at runtime based on context.SE-2098 async sequenceAsyncSequence and AsyncIteratorProtocol are new adding for concurrency for looping over asynchronous sequence of values.Ex:struct MyArray: AsyncSequence { struct MyIterator: AsyncIteratorProtocol { func next() async -&amp;gt; Int { 0 } }}for await item in myArray {}SE-0310 async readonly propertiesEx:struct User { var name: String { get async throws { try String(contentOf: ... ) } }}try await User().nameSE-0304 Structured concurrencyTask and TaskGroup allows us to run concurrent operations with a range of functions like execute, cancel, monitor etc.Ex:let myTask = Task { //...}let result = await myTask.value myTask will start running on background thread immediately Task starts running as soon as it is created. Task has priorities like high, low, default and background. userInitiated ~&amp;gt; high utility ~&amp;gt; low userInteractive ~&amp;gt; only for main thread Task can sleep, cancel, checkCancel and also yield() which suspends the current task for few moments in order to give sometime to any other task that might be waiting.SE-0317 async let bindingEx:func calculateAge() async -&amp;gt; Int { 0 }async let age = calculateAge() we can only use async let if we are already in a async context. try is not required for throwing functions try async let is not valid. It can automatically be pushed where we await result. func foo() async throws {} async let x = foo() try await x SE-0300 Continuations withCheckedContinuation swift performs runtime check to warn us about the resume call. withUnsafeContinuation swift does not performs any check resume function must be called ONLY once.Ex:func fetchData(_ completion: @escaping ([Int]) -&amp;gt; Void) {}func fetch() async -&amp;gt; [Int] { await withCheckedContinuation { cont in //1 fetchData { array in cont.resume(returning: array) //3 } }}SE-0306 Actors Actors are like classes which are safe to use in concurrent environment. Swift ensures that mutable state inside Actor are always accessed by one threat at any given time. Actors are like atomic classes. actor is the new type just like class, struct and enum. They can have methods, properties, initializers, subscripts and static properties. It can confirm to protocols and be generic. Actors can use its own properties and functions freely but if it is using another actor inside then it can be used only asynchronously. actor is a reference type just like a class. Actors do not support inheritance, so No overriding, No final, No super calls. All actors implicitly confirms to new Actor protocol.Ex:actor Foo { func jump() async {}}SE-0316 Global Actors@MainActor An attribute to mark properties and methods that should be used only on main thread. So we don’t need to check for Thread.isMainThread anymore. Functions marked with @MainActor can only be used via await or async letEx:class Foo { @MainActor func jump() {}}await Foo().jump()SE-0302 Sendable and its closureSendable protocol and @sendable closure attribute.func foo(_ completion: @escaping @sendable () -&amp;gt; Void) {} Sendable data can be safely transferred to another thread. All value types (Bool, String, Int, etc) confirms to Sendable protocol. Optional with value type, Dictionary with value type and Tuples confirms as well. Actors also confirm to Sendable because they handle their synchronization internally. Custom struct or enum also confirms if they only have value types or type that already confirm to Sendable. Same with class if they inherit from NSObject and they are marked final.SE-0308 Postfix member expressionMostly used in swift UIEx:#if OS(iOS)// ...#else//...#endif#if DEBUG#endifSE-0307 Interchangeable double and CGFloatNo more conversion requiredEx:let value = Double(3) + CGFloat(4)SE-2095 Codable for enum with associated valuesEx:enum Foo: Codable { case dance(Int)}lazy in local contextEx:func jump() { lazy var name = &quot;&quot;}SE-2093 Extended property wrapper for functions and closuresSE-2099 Extended static member lookup in generic contextReferences [Hacking With Swift] https://www.hackingwithswift.com/articles/233/whats-new-in-swift-5-5" }, { "title": "Big O notation", "url": "/posts/big-o-notation/", "categories": "Notes", "tags": "runtime", "date": "2021-08-23 13:41:10 +0400", "snippet": "Drop the constantsEx: Runtime $O(2N)$ will become $O(N)$Drop the non-dominant termsSince we drop constants therefore $O(N^2 + N^2)$ becomes $O(N^2)$. If we did not care about the latter $N^2$ why would we care about single $N$, we don’t.Ex: $O(N^2 + N)$ becomes $O(N^2)$ $O(N logN)$ becomes $O(N)$ $O(5 * 2^N * 100N^9)$ becomes $O(2^N)$but when we have two different runtime, we do not drop any $O(i + j)$ remain same because both are unknownAdd runtimesWhen an algorithm is in form of do this and when we are all done, do that then we add the runtimes.Ex:func foo() { for x in i {} for y in j {}}runtime would be $O(i + j)$Multiply runtimesWhen an algorithms is in form of do this for each time we do that then we multiply the runtimes.Ex:func foo() { for x in i { for y in j {} }}runtime would be $O(i * j)$Known lengthWhen array length is known that means it is a Constant and we drop the constant to calculate runtime.func foo() { for x in i { for y in j { for z in 1...1000 {} } }}Ex: $O(i * j * 1000)$ -&amp;gt; $O(i * j)$Recursive runtimeWhen we have a recursive function and that makes multiple recursive calls then the runtime will often (but not always) look like $O(branches^d)$ where branches are the number of times each recursive call branches.multiple recursive calls means an Exponential Runtime Runtime of a recursive function with multiple branches is $O(branch ^ d)$or When we see an algorithm with multiple recursive calls, we are looking at Exponential runtime.log runtimesWhen a number of elements in the problem space gets halved each time that will likely be a $O(log N)$ runtimeNot all binary search tree has log runtime.half runtimesWhen we divide the array by a constant it still runs an unknown number of times which is half of original.After dropping the dividend which is a known constant, runtime becomes $O(N)$.Amortize timeThe average time of best runtime $O(1)$ and worst runtime $O(N)$SpaceSince functions live in a stack, spaces are calculated likewise" }, { "title": "Codable", "url": "/posts/swift-codable/", "categories": "Notes", "tags": "swift, codable", "date": "2021-08-22 13:41:10 +0400", "snippet": "Decoding enumParsing a String value to an enum case with undefined case value to an unknown case using singleValueContainerenum Fruits: String, Decodable { case mango, banana, unknown /// If we don&#39;t implement init decoder then decoding will fail for unknown values init(from decoder: Decoder) throws { let rawValue = try decoder.singleValueContainer().decode(String.self) self = Fruits(rawValue: rawValue) ?? Fruits.unknown }}let json = &quot;&quot;&quot; [ &quot;mango&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;other&quot;, &quot;unknown&quot;, &quot;&quot;] &quot;&quot;&quot;.data(using: .utf8)!do { let fruits = try JSONDecoder().decode(Array&amp;lt;Fruits&amp;gt;.self, from: json) dump(fruits)} catch { dump(error)}// it will print two fruits cases and rest with unknown cases.Different data type in responseWhen we have two API return the same model with different data type values.struct IDE: Decodable { let name: String let build: String private enum CodingKeys: String, CodingKey { case name, build } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) name = try container.decode(String.self, forKey: .name) do { build = try container.decode(String.self, forKey: .build) } catch { let buildInt = try container.decode(Int64.self, forKey: .build) build = String(buildInt) } }}let json1 = &quot;&quot;&quot; { &quot;name&quot;: &quot;Xcode Beta&quot;, &quot;build&quot;: 1234, } &quot;&quot;&quot; .data(using: .utf8)!let json2 = &quot;&quot;&quot; { &quot;name&quot;: &quot;Xcode&quot;, &quot;build&quot;: &quot;1234&quot; } &quot;&quot;&quot; .data(using: .utf8)!do { let ideBeta = try JSONDecoder().decode(IDE.self, from: json1) dump(ideBeta) let ide = try JSONDecoder().decode(IDE.self, from: json2) dump(ide)} catch { dump(error)}Decoding optional keystruct IDE: Decodable { let isBeta: Bool? private enum CodingKeys: String, CodingKey { case isBeta } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) isBeta = try container.decodeIfPresent(Bool.self, forKey: .isBeta) }}let json1 = &quot;&quot;&quot; { &quot;isBeta&quot;: true } &quot;&quot;&quot; .data(using: .utf8)!let json2 = &quot;{}&quot;.data(using: .utf8)!do { let ideBeta = try JSONDecoder().decode(IDE.self, from: json1) dump(ideBeta) let ide = try JSONDecoder().decode(IDE.self, from: json2) dump(ide)} catch { dump(error)}Enum with associated value (before Swift 5.5)struct Square: Decodable { let sideLength: Int enum CodingKeys: String, CodingKey { case sideLength = &quot;side_length&quot; }}struct Sphere: Decodable { let diameter: Int}struct Cylinder: Decodable { let diameter: Int let height: Int}enum ObjectType: String, Decodable { case square case sphere case cylinder case unknown init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() let type = try container.decode(String.self) self = ObjectType(rawValue: type) ?? .unknown }}enum Object: Decodable { case square(Square) case sphere(Sphere) case cylinder(Cylinder) case unknown enum CodingKeys: String, CodingKey { case type } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) guard let type = try? container.decode(ObjectType.self, forKey: .type) else { self = .unknown return } let objectContainer = try decoder.singleValueContainer() switch type { case .square: let square = try objectContainer.decode(Square.self) self = .square(square) case .sphere: let sphere = try objectContainer.decode(Sphere.self) self = .sphere(sphere) case .cylinder: let cylinder = try objectContainer.decode(Cylinder.self) self = .cylinder(cylinder) case .unknown: self = .unknown } }}struct GeometricShapes: Decodable { let items: [Object]}let JSON = &quot;&quot;&quot; { &quot;items&quot;: [ { &quot;type&quot;: &quot;square&quot;, &quot;side_length&quot;: 12 }, { &quot;type&quot;: &quot;sphere&quot;, &quot;diameter&quot;: 4 }, { &quot;type&quot;: &quot;cylinder&quot;, &quot;diameter&quot;: 4, &quot;height&quot;: 10 }, { &quot;type&quot;: &quot;lalala&quot;, &quot;unknown_key&quot;: 0 } ] }&quot;&quot;&quot;.data(using: .utf8)!let geometricObjects = try JSONDecoder().decode(GeometricShapes.self, from: JSON)dump(geometricObjects)Decoding dynamic keyslet json = &quot;&quot;&quot; { &quot;S001&quot;: { &quot;firstName&quot;: &quot;Tony&quot;, &quot;lastName&quot;: &quot;Stark&quot; }, &quot;S002&quot;: { &quot;firstName&quot;: &quot;Peter&quot;, &quot;lastName&quot;: &quot;Parker&quot; }, &quot;S003&quot;: { &quot;firstName&quot;: &quot;Bruce&quot;, &quot;lastName&quot;: &quot;Wayne&quot; } } &quot;&quot;&quot;.data(using: .utf8)!struct Student: Decodable { let firstName: String let lastName: String let studentId: String enum CodingKeys: CodingKey { case firstName case lastName } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) firstName = try container.decode(String.self, forKey: CodingKeys.firstName) lastName = try container.decode(String.self, forKey: CodingKeys.lastName) studentId = container.codingPath.first!.stringValue }}struct ClassX: Decodable { var students: [Student] private struct DynamicCodingKeys: CodingKey { // Use for string-keyed dictionary var stringValue: String init?(stringValue: String) { self.stringValue = stringValue } // Use for integer-keyed dictionary var intValue: Int? init?(intValue: Int) { // We are not using this, thus just return nil return nil } } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: DynamicCodingKeys.self) var tempArray = [Student]() for key in container.allKeys { let decodedObject = try container.decode(Student.self, forKey: key) tempArray.append(decodedObject) } students = tempArray }}let result = try! JSONDecoder().decode(ClassX.self, from: json)dump(result)Decoding key as valuelet json = &quot;&quot;&quot; { &quot;Xcode&quot;: &quot;123xb&quot;, &quot;AndroidStudio&quot;: &quot;345JK&quot;, &quot;VSCode&quot;: &quot;89sdfu89&quot;, &quot;Slack&quot;: &quot;uojakls89&quot; } &quot;&quot;&quot;.data(using: .utf8)!struct Data: Decodable { let softwares: [Software] private struct DynamicCodingKeys: CodingKey { var stringValue: String init?(stringValue: String) { self.stringValue = stringValue } var intValue: Int? init?(intValue: Int) { return nil } } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: DynamicCodingKeys.self) var tempArray = [Software]() for key in container.allKeys { let name = key.stringValue let build = try container.decode(String.self, forKey: key) tempArray.append(Software(name: name, build: build)) } softwares = tempArray }}struct Software: Decodable { let name: String let build: String}do { let result = try JSONDecoder().decode(Data.self, from: json) dump(result.softwares)} catch { dump(error)}Decoding single key valuelet json = &quot;&quot;&quot; { &quot;Xcode&quot;: &quot;123xb&quot; } &quot;&quot;&quot;.data(using: .utf8)!struct Software: Decodable { let name: String let build: String private struct DynamicCodingKeys: CodingKey { var stringValue: String init?(stringValue: String) { self.stringValue = stringValue } var intValue: Int? init?(intValue: Int) { return nil } } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: DynamicCodingKeys.self) if let key = container.allKeys.first { name = key.stringValue build = try container.decode(String.self, forKey: key) } else { throw DecodingError.dataCorruptedError(forKey: DynamicCodingKeys(stringValue: &quot;&quot;)!, in: container, debugDescription: &quot;Some error&quot;) } }}do { let result = try JSONDecoder().decode(Software.self, from: json) dump(result)} catch { dump(error)}Decoding different types in a collectionlet json = &quot;&quot;&quot; { &quot;todo&quot;: { &quot;banana&quot;: 6, &quot;apple&quot;: 3, &quot;rice&quot;: &quot;200g&quot;, &quot;beans&quot;: &quot;500g&quot; } } &quot;&quot;&quot; .data(using: .utf8)!class WrappedString: Codable { let value: String required init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() do { // Try to parse it as a String value = try container.decode(String.self) } catch { if let tempValue = try? container.decode(Int.self) { value = String(tempValue) } else { throw error } } }}class TODO: Codable { let items : [String: String] private enum CodingKeys: String, CodingKey { case items = &quot;todo&quot; } required init(from decoder: Decoder) throws { let decoder = try decoder.container(keyedBy: CodingKeys.self) let values = try decoder.decode([String: WrappedString].self, forKey: .items) items = values.mapValues { $0.value } }}do { let result = try JSONDecoder().decode(TODO.self, from: json) dump(result)} catch { dump(error)}Decoding Date URL formatterlet json = &quot;&quot;&quot; { &quot;name&quot;: &quot;Apple&quot;, &quot;urlAddress&quot;: &quot;www.apple.com&quot;, &quot;isoFormattedDate&quot;: &quot;1975-01-24T21:30:31Z&quot; } &quot;&quot;&quot; .data(using: .utf8)!struct Company: Decodable { let name: String let urlAddress: URL let isoFormattedDate: Date}var dateFormatter: DateFormatter = { let dateFormatter = DateFormatter() dateFormatter.dateFormat = &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;&quot; return dateFormatter}()do { let decoder = JSONDecoder() decoder.dateDecodingStrategy = .formatted(dateFormatter) let company = try decoder.decode(Company.self, from: json) print(company)} catch { print(error.localizedDescription)}do { let decoder = JSONDecoder() decoder.dateDecodingStrategy = .iso8601 let company = try decoder.decode(Company.self, from: json) print(company)} catch { print(error.localizedDescription)}Decoding different key for same structurelet serviceOneJSON = &quot;&quot;&quot;{ &quot;user_name&quot;: &quot;Mukesh&quot;, &quot;user_tagline&quot;: &quot;Experience is the name everyone gives to their mistakes&quot;, &quot;id&quot;: 1}&quot;&quot;&quot;.data(using: .utf8)!let serviceTwoJSON = &quot;&quot;&quot;{ &quot;full_name&quot;: &quot;Mukesh Mandora&quot;, &quot;status&quot;: &quot;In order to be irreplaceable, one must always be different&quot;, &quot;user_id&quot;: 12}&quot;&quot;&quot;.data(using: .utf8)!struct UserOfProduct: Decodable { var name: String? var userId: Int? var tagline: String? enum ServiceOneCodingKeys: String, CodingKey { case name = &quot;user_name&quot; case userId = &quot;id&quot; case tagline = &quot;user_tagline&quot; } enum ServiceTwoCodingKeys: String, CodingKey { case name = &quot;full_name&quot; case userId = &quot;user_id&quot; case tagline = &quot;status&quot; } init(from decoder: Decoder) throws { // Service One JSON Container let containerForServiceOne = try decoder.container(keyedBy: ServiceOneCodingKeys.self) userId = try containerForServiceOne.decodeIfPresent(Int.self, forKey: .userId) name = try containerForServiceOne.decodeIfPresent(String.self, forKey: .name) tagline = try containerForServiceOne.decodeIfPresent(String.self, forKey: .tagline) // Check any one param which is required to not be nil in this case // userId, based on that we will take decision to decode from another container guard userId == nil else { return } // Service Two JSON Container let containerForServiceTwo = try decoder.container(keyedBy: ServiceTwoCodingKeys.self) userId = try containerForServiceTwo.decodeIfPresent(Int.self, forKey: .userId) name = try containerForServiceTwo.decodeIfPresent(String.self, forKey: .name) tagline = try containerForServiceTwo.decodeIfPresent(String.self, forKey: .tagline) // Failure send crash report to find this unknown keys guard userId != nil else { fatalError(&quot;Decooding error&quot;) } }}let userObjectFromServiceOne = try! JSONDecoder().decode(UserOfProduct.self, from: serviceOneJSON)print(&quot;User Name from Service One, \\(userObjectFromServiceOne.name ?? &quot;&quot;)&quot;)print(&quot;User Tagline from Service One, \\(userObjectFromServiceOne.tagline ?? &quot;&quot;)&quot;)let userObjectFromServiceTwo = try! JSONDecoder().decode(UserOfProduct.self, from: serviceTwoJSON)print(&quot;User Name from Service Two, \\(userObjectFromServiceTwo.name ?? &quot;&quot;)&quot;)print(&quot;User Tagline from Service Two, \\(userObjectFromServiceTwo.tagline ?? &quot;&quot;)&quot;)orlet serviceOneJSON = &quot;&quot;&quot;{ &quot;user_name&quot;: &quot;Mukesh&quot;, &quot;user_tagline&quot;: &quot;Experience is the name everyone gives to their mistakes&quot;, &quot;id&quot;: 1}&quot;&quot;&quot;.data(using: .utf8)!let serviceTwoJSON = &quot;&quot;&quot;{ &quot;full_name&quot;: &quot;Mukesh Mandora&quot;, &quot;status&quot;: &quot;In order to be irreplaceable, one must always be different&quot;, &quot;user_id&quot;: 12}&quot;&quot;&quot;.data(using: .utf8)!struct UserOfProduct: Decodable { var name: String var userId: Int var tagline: String enum ServiceOneCodingKeys: String, CodingKey { case name = &quot;user_name&quot; case userId = &quot;id&quot; case tagline = &quot;user_tagline&quot; } enum ServiceTwoCodingKeys: String, CodingKey { case name = &quot;full_name&quot; case userId = &quot;user_id&quot; case tagline = &quot;status&quot; } init(from decoder: Decoder) throws { if let containerForServiceOne = try? decoder.container(keyedBy: ServiceOneCodingKeys.self), let userId = try? containerForServiceOne.decode(Int.self, forKey: .userId), let name = try? containerForServiceOne.decode(String.self, forKey: .name), let tagline = try? containerForServiceOne.decode(String.self, forKey: .tagline) { self.userId = userId self.name = name self.tagline = tagline } else if let containerForServiceTwo = try? decoder.container(keyedBy: ServiceTwoCodingKeys.self), let userId = try? containerForServiceTwo.decode(Int.self, forKey: .userId), let name = try? containerForServiceTwo.decode(String.self, forKey: .name), let tagline = try? containerForServiceTwo.decode(String.self, forKey: .tagline) { self.userId = userId self.name = name self.tagline = tagline } else { fatalError(&quot;Decooding error&quot;) } }}let userObjectFromServiceOne = try! JSONDecoder().decode(UserOfProduct.self, from: serviceOneJSON)print(&quot;User from Service One, \\(userObjectFromServiceOne)&quot;)let userObjectFromServiceTwo = try! JSONDecoder().decode(UserOfProduct.self, from: serviceTwoJSON)print(&quot;User from Service Two, \\(userObjectFromServiceTwo)&quot;)Throwing custom error/// When we want to throw a custom error messageenum Fruits: String, Decodable { case mango, banana, unknown private enum CodingKeys: CodingKey { case type } init(from decoder: Decoder) throws { var container = try decoder.unkeyedContainer() let type = try container.decode(String.self) if let val = Fruits(rawValue: type) { self = val } else { throw DecodingError.dataCorruptedError(in: container, debugDescription: &quot;Wrong value&quot;) } }}let json = &quot;&quot;&quot; [ &quot;mangooo&quot; ] &quot;&quot;&quot; .data(using: .utf8)!do { let fruits = try JSONDecoder().decode(Fruits.self, from: json) print(fruits)} catch { print(error)}References Flight school guide to Codable" }, { "title": "Swift 5.3 notes", "url": "/posts/swift-5-3/", "categories": "Notes", "tags": "swift", "date": "2021-08-20 13:41:10 +0400", "snippet": "SE-2076 Multi-pattern catch clausedo { //...} catch MyError.code1, MyError.code2 {}SE-2079 Multiple trailing closureNo need for small curly braces anymore.Button { //...} label { // ...} action { // ...}SE-2066 Comparable conformance for enumNow we can compare enum case with &amp;gt; or &amp;lt; or etc.enum Size { case small case large}if Size.small &amp;lt; Size.large {}SE-2081 @main attributeType based program entry point@main struct MyApp { static main() {}}It requires a static main function.SE-0267 where clause inside a generic type or extensionstruct Foo&amp;lt;Element&amp;gt; {}extension Foo { func jump() -&amp;gt; Element where Element: Comparable {}}SE-0280 enum cases as protocol matching witnessprotocol Foo { var name: String}enum Zoo: Foo { case name}References [Hacking With Swift] https://www.hackingwithswift.com/articles/218/whats-new-in-swift-5-3" }, { "title": "Swift logs", "url": "/posts/swift-logs/", "categories": "Notes", "tags": "swift, logs", "date": "2021-08-16 13:41:10 +0400", "snippet": "There are many ways we can log our data in standard output console and few of them also supports logging in Console.app. Let’s have a look at them: print() debugPrint() dump() NSLog OSLog Logger and etc.print API reference: https://developer.apple.com/documentation/swift/1541053-print It prints the given text to the standard output. It supports multiple arguments and converts those to String representable before printing. It terminates with a new line character as default which can be overridden. We can also pass separator to be printed between arguments.func print(_ items: Any..., separator: String = &quot; &quot;, terminator: String = &quot;\\n&quot;)print(1, 1.2, false, &quot;&quot;) // 1 1.2 false print(1, 1.2, false, &quot;&quot;, separator: &quot; | &quot;) // 1 | 1.2 | false | print(&quot;Apple&quot;, terminator: &quot;&quot;) //AppledebugPrint API reference: https://developer.apple.com/documentation/swift/1539920-debugprint It is similar to print except that it adds some additional information like type name etc. It prints things like \\n \\t as is, without formatting the text. if we implement both CustomDebugStringConvertible and CustomStringConvertible protocol, then debugPrint method default use debugDescription content, and print method default use description content.func debugPrint(_ items: Any..., separator: String = &quot; &quot;, terminator: String = &quot;\\n&quot;)print(&quot;&quot;) // debugPrint(&quot;&quot;) // &quot;&quot;struct Foo { let name = &quot;jump&quot;}print(Foo()) // Foo(name: &quot;jump&quot;)debugPrint(Foo()) // __lldb_expr_1.Foo(name: &quot;jump&quot;)dump API reference: https://developer.apple.com/documentation/swift/1539127-dump It prints given object’s content using its mirror. It prints almost same information as debugPrint except it starts with a dash character. It has more parameters to configure like name = gives name to the value printed indent = gives indentation before the dash character maxDepth = specifies the maximum depth for descendants maxItems = specifies the maximum number of elements to print full content dump(&quot;&quot;) // - &quot;&quot;dump(Foo())/*▿ __lldb_expr_15.Foo - name: &quot;jump&quot;*/dump(&quot;Apple&quot;, name: &quot;Company&quot;, indent: 4, maxDepth: 5, maxItems: 5)// output: - Company: &quot;Apple&quot;NSLog It comes from Objective-C world. It is not a recommended solution for Swift. It is not part of Swift standard library, it requires Foundation framework to be imported.OSLog It prints log messages on unified logging system (Console.app). It requires OSLog framework to be imported. It does not work with Linux or Windows platform. It supports many log levels default = is notice info debug error fault os_log parameters %{public}@ = prints the given argument info as is. %{private}@ = hides the given argument info &amp;lt;private&amp;gt; in Console.app but will be visible in Xcode console.func os_log(_ type: OSLogType, dso: UnsafeRawPointer = #dsohandle, log: OSLog = .default, _ message: StaticString, _ args: CVarArg...)os_log(&quot;message&quot;)let log = OSLog(subsystem: &quot;appName&quot;, category: &quot;login&quot;)os_log(&quot;apple&quot;, log: log, type: .info)os_log(&quot;My id %{private}@ &quot;, log: log, type: .info, &quot;abc123&quot;)// My id &amp;lt;private&amp;gt;Logger Came with iOS 14, improved version of OSLog Has similar initializer as OSLog with subsystem and category All the log levels are in form of functions here. Privacy level can be configured using enum unlike string in OSLog. It provide some nice APIs like setting alignment and formatting double value .fixed(precision:) etc.let log = Logger(subsystem: &quot;app&quot;, category: &quot;viewcycle&quot;)log.info(&quot;info message&quot;)log.debug(&quot;My id \\(&quot;abc123&quot;, privacy: .private)&quot;)log.debug(&quot;Employee \\(&quot;name&quot;, align: .left(columns: 10))&quot;)PersistentThese log messages are stored in disks based on their type. Debug is not persisted, info is only persisted during log collect option, and the rest are persisted until storage limit.Open sourceCustom Dump from Point Freehttps://www.pointfree.co/blog/posts/62-open-sourcing-custom-dumpCocoaLumberjackhttps://cocoalumberjack.github.ioFurther readingApple DocsThere is an article from apple on Generating Log Messages from Your Code.It tells about how to use the new Logging Framework and its APIs in details.https://steipete.com/posts/logging-in-swift/Peter Steinberger has written an in-depth article on os_log and new logging APIs.WWDC videosThere are few videos from WWDC Video - Measuring Performance Using Logging Video - Explore logging in Swift" }, { "title": "Combine In-Practice!", "url": "/posts/combine-in-practice/", "categories": "Notes", "tags": "swift, combine", "date": "2020-05-21 13:41:10 +0400", "snippet": "Key Points Apple introduced a new framework to deal with asynchronous programming called Combine in WWDC 2019. A framework which provides stream of events which can emits values and optionally end in a success or error. Or It is a declarative Swift API for processing values over time. Or It provides a native way of handling asynchronous events. The biggest caveat at the moment is that it is only available for iOS 13 and above. Combine lacks proper documentations and also does not have anything similar to RxCocoa where we could map our UI elements with Publishers and Subscribers.Key Concepts Publisher Subscriber Subscription CancellablePublisher:- Publishers are the declarative part of Combine’s API. They describe how values and errors are produced. But they don’t produce, they publishes. we’ll see how. Publishers are value types, so they are struct. Publishers also allow for registrations of a subscriber. Something which receives values overtime. Publishes a stream of values, which becomes accessible only when subscribed to.protocol Publisher { associatedtype Output associatedtype Failure: Error func subscribe&amp;lt;S: Subscriber&amp;gt;(_ subscriber: S) where S.Input == Output, S.Failure == Failure} It is defined as a protocol with two associated type values Output and Failure. If it is not possible for a publisher to produce an error, then we can use the type Never for the associated type. Publisher has one key function called subscribe()Built in Publishers NotificationCenter DataRequest Timer and etcSubscriber:- Subscribers are the counterpart to Publishers. They receive values including the completion. Usually Subscribers act and mutate state upon receipt of values, and for mutating state we use reference types in Swift. This means that they are Classes.protocol Subscriber { associatedtype Input associatedtype Failure: Error func receive(subscription: Subscription) func receive(_ input: Input) -&amp;gt; Subscribers.Demand func receive(completion: Subscribers.Completion&amp;lt;Failure&amp;gt;)} It is defines as a protocol with two associated type values Input and Failure. Input type must match with its Publisher’s Output. It has 3 key functions It can receive a subscription receive(subscription: Subscription) It can receive an Input It can receive completionBuilt in Subscriber Sink Assign and etc So till now we’ve got the idea about publisher and subscriber. It’s obvious, that we have a publisher — that thing, which gives us values, and a subscriber, which requests this values for its own purpose. But the main part of this collaboration is usually hidden. I’m ? talking about subscription by itself, and that’s where all the magic happens. Subscription is like Interactor, ViewModel or simply Brain of publisher-subscriber collaboration. The publisher creates a subscription with all required dependencies and gives it to the subscriber. After this, the subscription starts acting and processing values over time. Then subscriber consumes these values and we can receive them in the sink closure.Subscription A subscription is how a subscriber controls the flow of data from Publisher to a Subscriber.protocol Subscription: Cancellable { func request(_ demand: Subscribers.Demand)} It’s a protocol which inherits Cancellable It has an only function which requests for the Demand a struct. Which defines the number of values a subscriber is subscribed to. There are three types of Demand .none, .unlimited and .max(Int) For example sink subscriber function is always subscribe to .unlimited values.Cancellable A confusing one, because there’s not much documentation around it. Cancellation is also build into combine. Whenever a subscriber no longer needs to receive elements from a publisher, it may cancel its subscription. means set it to nil. Cancellation allows your to tear down the sequence of Publisher and subscribers early if we need to.protocol Cancellable { func cancel()} It’s a protocol, which has a function to cancel the current subscription. It is documented that each subscriber should implement cancellable but how and flow are not mentioned. If we do not implement, I’ve not figured how it will affect. The subscriber types created by sink(receiveCompletion:receiveValue:) and assign(to:on:) both implement the Cancellable protocol, which provides a cancel() method. and they actually return AnyCancellable.The Flow/PatternDemo Time Existing publisher and subscriber Custom publisher Custom subscriberOther Operators Subjects Type Erasers RxSwift vs Combine etcOperators Operators are Publisher, and they are also declarative and therefore the value types. Changing behavior, adding values, removing values or etc They subscribe to another publisher (upstream) and They send result to subscriber (downstream)Subjects Subjects act both as a Subscriber and a Publisher. While a subject can receive values from an upstream publisher, it can also pass along these values to its downstream subscribers.let currentSubject = CurrentValueSubject(1)A CurrentValueSubject will hold an initial value.let passthroughSubject = PassthroughSubject()A passthrough subject will start emitting values only when it gets subscribed to.Type Erasers AnySubscriber wraps the Publisher protocol. AnyPublisher wraps the Subscriber protocol. AnySubject wraps a subject. AnyCancellable is a type-erased class that will automatically call cancel() on deinit using Swift’s memory management system.RxSwift vs. CombineIf we look into the APIs of RxSwift and ReactiveSwift, we could say that Combine is inspired by these framework API set. It is very similar when compared, and now there is a cheatsheet available as well which lists components and operators of Combine and RxSwift frameworks:https://github.com/CombineCommunity/rxswift-to-combine-cheatsheetIn RxSwift.. Publishers are Observables Subscribers are Observers Cancellable is Disposable (There’s no DisposeBag) CurrentValueSubject is BehaviorSubject PassthroughSubject is PublishSubject eraseToAnyPublisher is asObservable handleEvents() is do() Single is FutureThanks for the read, see you in next article :)" }, { "title": "Combine Introduction!", "url": "/posts/combine-introduction/", "categories": "Notes", "tags": "swift, combine", "date": "2020-05-20 13:41:10 +0400", "snippet": " Apple introduced a new framework to deal with asynchronous programming called Combine in WWDC 2019. A framework which provides stream of data which can emits values and optionally end in a success or error. It is a declarative Swift API for processing values over time.Caveat The biggest caveat at the moment is that it is only available for iOS 13 and above. Combine also does not have anything similar to RxCocoa where we could map our UI elements with Publishers and Subscribers.What the benefits of using it Since it is a way to write reactive programming, which means it executes its operations asynchronously. Using combine won’t change the way we write our code. we could still follow our all the design patterns we are using and keep our architecture intact. The only thing we need to make sure that we understand the APIs clearly as If we’ve an experience with RxSwift/Reactive Programming then we might messed-up with API names and outcomes.How it stands against Rx If we look into the APIs of RxSwift and ReactiveSwift, we could say that Combine is inspired by these framework API set. It is very similar when compared, and now there is a cheat-sheet available as well which lists components and operators of Combine and RxSwift frameworks:CheatSheetBasics   RxSwift Combine Deployment Target iOS 8.0+ iOS 13.0+ Platforms supported iOS, macOS, tvOS, watchOS, Linux iOS, macOS, tvOS, watchOS, UIKit for Mac ¹ UI Bindings RxCocoa SwiftUI ² Core Components RxSwift Combine Notes Observable Publisher   Observer Subscriber   AnyObserver AnySubscriber   Disposable Cancellable   DisposeBag A collection of AnyCancellables Call anyCancellable.store(in: collection), where collection can be an array, a set, or any other RangeReplaceableCollection Driver BindableObject (SwiftUI) Both guarantee no failure, but Driver guarantees delivery on Main Thread. In Combine, SwiftUI recreates the entire view hierarchy on the Main Thread, instead. PublishSubject PassthroughSubject   BehaviorSubject CurrentValueSubject This seems to be the type that holds @State under the hood SchedulerType Scheduler   How big is learning curveIt is not difficult for anyone who knows any reactive programming whether it is RxSwift or ReactiveSwift.It is similar in core concept only API differs.Exampleslet publisher = Just(23)_ = publisher.sink { print($0) // It will emit 23 here}&quot;23&quot;.publisher.sink { print($0) }[1,2,3,4,5].publisher.sink { print($0) }Thanks for the read, see you in next article :)" }, { "title": "autoreleasepool", "url": "/posts/autoreleasepool/", "categories": "Notes", "tags": "objective-c", "date": "2018-08-14 09:41:10 +0400", "snippet": "High-Level Overview The ball gets rolling when the autorelease message is sent to an object. autorelease is implemented on NSObject, and just calls through to [NSAutoreleasePool addObject: self]. This is a class method, which then needs to track down the right instance to talk to.NSAutoreleasePool instances are stored in a per-thread stack. When a new pool is created, it gets pushed onto the top of the stack. When a pool is destroyed, it’s popped off the stack. When the NSAutoreleasePoolclass method needs to look up the current pool, it grabs the stack for the current thread and grabs the pool at the top.Once the right pool is found, the addObject: instance method is used to add the object to the pool. When an object is added to the pool, it’s just added to a list of objects kept by the pool.When a pool is destroyed, it goes through this list of objects and sends release to each one. This is just about all there is to it. There is one additional small complication: if a pool is destroyed which is not at the top of the stack of pools, it also destroys the other pools which sit above it. In short, NSAutoreleasePool instances nest, and if you fail to destroy an inner one, the outer one will take care of it when it gets destroyed.Garbage Collection NSAutoreleasePool exists under garbage collection and is even slightly functional. If you use the drainmessage rather than the release message, destroying a pool under garbage collection signals to the collector that this might be a good time to run a collection cycle. Aside from this, however, NSAutoreleasePool does nothing under garbage collection and isn’t very interesting to consider there. There’s no way to tell if an object has been autoreleased. The pool is a fairly dumb container with only the barest idea of what it contains. It really just keeps a list for the purposes of sending release to those objects later. This is perfectly fine, because your code should never care whether an object has already been autoreleased. Objects that are autoreleased twice just get added to the pool twice, and then when the pool is destroyed they get released twice. Autoreleased objects get released when the current autorelease pool is destroyed. Pools are destroyed when the code that created them explicitly destroys them. If you aren’t managing your own pools, then autoreleased objects will survive at least until you return to the code you don’t own (like Cocoa). If you autorelease an object on one thread and then pass it to another thread, nothing special happens. The object is still released when the first thread’s pool gets destroyed, regardless of what’s happening on the new thread. If you need an object to survive the passage, it needs to be retained before sending and then released after receiving. (Fortunately, the cross-thread messaging mechanisms you’re likely to use with objects, like GCD/blocks and Cocoa’s perform... methods do this for you.)The @autorelease keyword generates calls to objc_autoreleasePoolPush() andobjc_autoreleasePoolPop(), which use pool tokens directly. I presume an NSAutoreleasePool is now a simple wrapper for a pool token.Core Foundation @autorelease in ARC Without ARC to autorelease a CoreFoundation object:CFDictionaryRef MakeDictionary(void) { CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, NULL, NULL); // Put some stuff in the dictionary here perhaps \\[(id)dict autorelease\\]; return dict;}This above code no longer works with ARC, because the call to autorelease is not permitted. To solve this, Apple helpfully provided us with a CFAutorelease function which does the same thing and can be used with ARC. Unfortunately, it’s only available as of iOS 7 and Mac OS X 10.9.iOS 6 support for autorelease with ARC.CFDictionaryRef MakeDictionary(void) { CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, NULL, NULL); // Put some stuff in the dictionary here perhaps SEL autorelease = sel\\_getUid(&quot;autorelease&quot;); IMP imp = class\\_getMethodImplementation(object\\_getClass((\\_\\_bridge id)dict), autorelease); ((CFTypeRef (\\*)(CFTypeRef, SEL))imp)(dict, autorelease); return dict;}" }, { "title": "Operating System", "url": "/posts/operating-system/", "categories": "Notes", "tags": "os", "date": "2016-06-04 09:41:10 +0400", "snippet": "Sharing my very old notes on operating system.Reliability: can be defined as the probability that a system will produce correct outputs up to some given time t. Reliability is enhanced by features that help to avoid, detect and repair hardware faults. A reliable system does not silently continue and deliver results that include uncorrected corrupted data. Instead, it detects and, if possible, corrects the corruption.Availability: means the probability that a system is operational at a given time, i.e. the amount of time a device is actually operating as the percentage of total time it should be operating. High-availability systems may report availability in terms of minutes or hours of downtime per year. Availability features allow the system to stay operational even when faults do occur.Scalability: The ability to retain performance levels when adding additional processors.Clock Speed: The Clock Speed (of CPU) is used to determine the maximum amount of wok a computer (CPU) can perform in a specific time (a time unit). So we can say, our system executes our programs with x clock speed.Thread: From a technical standpoint, a thread is a combination of the kernel-level and application-level coding (data structure), which is needed to manage the execution of code or a task. The kernel-level structures coordinate the dispatching of events to the thread and the preemptive scheduling of the thread on one of the available cores. The application-level structures include the call stack for storing function calls and the structures the application needs to manage and manipulate the thread’s attributes and state.Difference between Task_,_ Process and ThreadsThreads are used for small tasks, whereas processes are used for more ‘heavyweight’ tasks – basically the execution of applications. Another difference between a thread and a process is that threads within the same process share the same address space, whereas different processes do not.Process Each process provides the resources needed to execute a program. A process has a virtual address space, executable code, open handles to system objects, a security context, a unique process identifier, environment variables, a priority class, minimum and maximum working set sizes, and at least one thread of execution. Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.Thread A thread is the entity within a process that can be scheduled for execution. All threads of a process share its virtual address space and system resources. In addition, each thread maintains exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and a set of structures the system will use to save the thread context until it is scheduled. The thread context includes the thread’s set of machine registers, the kernel stack, a thread environment block, and a user stack in the address space of the thread’s process. Threads can also have their own security context, which can be used for impersonating clients.Cloud computing, also on-demand computing, is a kind of Internet-based computingthat provides shared processing resources and data to computers and other devices on demand.Virtual memory is a feature of an operating system (OS) that allows a computer to compensate for shortages of physical memory by temporarily transferring pages of data from random access memory(RAM) to disk storage.Critical Section: In concurrent programming, a critical section is a part of a multi-process program that may not be concurrently executed by more than one of the program’s processes. In other words, It is a piece of a program that requires mutual exclusion of access. Typically, the critical section accesses a shared resource, such as a data structure, a peripheral device, or a network connection, that does not allow multiple concurrent accesses. A critical section may consist of multiple discontiguous parts of the program’s code. For example, one part of a program might read from a file that another part wishes to modify. These parts together form a single critical section, since simultaneous readings and modifications may interfere with each other. Since critical sections may execute only on the processor on which they are entered, synchronization is only required within the executing processor.Concurrency issues Resource Starvation: In computer science, starvation is a problem encountered in concurrent computing where a process is perpetually denied necessary resources to process its work. Starvation may be caused by errors in a scheduling or mutual exclusion algorithm, but can also be caused by resource leaks Mutual Exclusion: Mutual exclusion is in many ways the fundamental issue in concurrency. It is the requirement that when a process P is accessing a shared resource R, no other process should be able to access R until P has finished with R. Examples of such resources include files, I/O devices such as printers, and shared data structures.A Mutex (Lock) is locking mechanism used to synchronize access to a resource. Only one task (can be a thread or process based on OS abstraction) can acquire the mutex. It means there will be ownership associated with mutex, and only the owner can release the lock (mutex). - very good answer http://stackoverflow.com/a/346678 Semaphore is signaling mechanism (“I am done, you can carry on” kind of signal). For example, if you are listening songs (assume it as one task) on your mobile and at the same time your friend called you, an interrupt will be triggered upon which an interrupt service routine (ISR) will signal the call processing task to wakeup.Deadlock / Livelock (how to avoid?) http://wikipedia.moesalih.com/Deadlock#Livelock http://stackoverflow.com/questions/6155951/whats-the-difference-between-deadlock-and-livelockDEADLOCK Deadlock is a condition in which a task waits indefinitely for conditions that can never be satisfied - task claims exclusive control over shared resources - task holds resources while waiting for other resources to be released - tasks cannot be forced to relinguish resources - a circular waiting condition exists Deadlock: A situation in which two or more processes are unable to proceed because each is waiting for one the others to do something. For example, consider two processes, P1 and P2, and two resources, R1 and R2. Suppose that each process needs access to both resources to perform part of its function. Then it is possible to have the following situation: the OS assigns R1 to P2, and R2 to P1. Each process is waiting for one of the two resources. Neither will release the resource that it already owns until it has acquired the other resource and performed the function requiring both resources. The two processes are deadlockedLive Locked threads are unable to make further progress. However, the threads are not blocked — they are simply too busy responding to each other to resume work. Livelock: A situation in which two or more processes continuously change their states in response to changes in the other process(es) without doing any useful work: Starvation: A situation in which a runnable process is overlooked indefinitely by the scheduler; although it is able to proceed, it is never chosen. Example: Suppose that three processes (P1, P2, P3) each require periodic access to resource R. Consider the situation in which P1 is in possession of the resource, and both P2 and P3 are delayed, waiting for that resource. When P1 exits its critical section, either P2 or P3 should be allowed access to R. Assume that the OS grants access to P3 and that P1 again requires access before P3 completes its critical section. If the OS grants access to P1 after P3 has finished, and subsequently alternately grants access to P1 and P3, then P2 may indefinitely be denied access to the resource, even though there is no deadlock situation. A live lock is similar to a deadlock, except that the states of the processes involved in the livelock constantly change with regard to one another, none progressing. Livelock is a special case of resource starvation; the general definition only states that a specific process is not progressing. A real-world example of livelock occurs when two people meet in a narrow corridor, and each tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they both repeatedly move the same way at the same time. Livelock is a risk with some algorithms that detect and recover from deadlock. If more than one process takes action, the deadlock detection algorithm can be repeatedly triggered. This can be avoided by ensuring that only one process (chosen randomly or by priority) takes action.Context switch: http://wikipedia.moesalih.com/Context_switch In computing, a context switch is the process of storing and restoring the state (more specifically, the execution context) of a process or thread so that execution can be resumed from the same point at a later time. This enables multiple processes to share a sing CPU and is an essential feature of a multitasking operating system.Process Scheduling: Job scheduler selects processes from the queue and loads them into memory for execution. Process loads into the memory for CPU scheduling. The primary objective of the job scheduler is to provide a balanced mix of jobs, such as I/O bound and processor bound. http://www.tutorialspoint.com/operating_system/os_process_scheduling.htmRace Condition: A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, but because of the nature of the device or system, the operations must be done in the proper sequence in order to be done correctly.Green Thread: Green threads are threads that are scheduled by a runtime library or virtual machine (VM) instead of natively by the underlying operating system. Green threads emulate multithreaded environments without relying on any native OS capabilities, and they are managed in user space instead of kernel space, enabling them to work in environments that do not have native thread supportMultiprocessing — multiple CPUs executing concurrently Multitasking — the operating systems simulates concurrency on a single CPU by interleaving the execution of different tasks. Awesome Answer about Concurrency and Parallelism: http://stackoverflow.com/a/24684037 Detailed here: http://sce.uhcl.edu/helm/rationalunifiedprocess/process/workflow/ana_desi/co_cncry.htm Objective C: https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/Interrupt-ability - Concurrency is when two or more tasks can start, run, and complete in overlapping time periods. It doesn’t necessarily mean they’ll ever both be running at the same instant. Eg. multitasking on a single-core machine. A condition that exists when at least two threads are making progress. A more generalized form of parallelism that can include time-slicing as a form of virtual parallelism.Independent-ability Parallelism is when tasks literally run at the same time, eg. on a multicore processor. A condition that arises when at least two threads are executing simultaneously.Conditions for Deadlock: Three policy conditions are necessary for deadlock to be possible. Mutual exclusion Only one process may use a resource at one time. Hold and wait A process may hold some resources while waiting for others. No preemption No process can be forced to release a resource. A fourth condition is required for deadlock to actually occur. Circular wait A closed chain of processes exists, such that each process is blocked waiting for a resource held by another process in the set. Three approaches exist for dealing with deadlock. Prevention involves adopting a static policy that disallows one of the four conditions above. Avoidance involves making dynamic choices that guarantee prevention. Detection and recovery involves recognising when deadlock has occurred, and trying to recover.Deadlock Prevention: We can prevent deadlock from occurring by adopting either an indirect policy that disallows one of the three necessary conditions, or a direct policy that disallows sets of processes that can exhibit a circular wait.Scalability Issues with synchronizationScalability: The ability to retain performance levels when adding additional processors. In context of mutual exclusion ME lock. Latency: If a thread wants to acquire a lock, it has to do some operations, it has to go to memory, get this lock and make sure no one else is competing with it. So the time that is spent by a thread in acquiring the lock is called Latency. Latency is saying, lock is currently not being used. How long does it take for me to go and get it. That really the key question that latency is. Waiting Time: Scalability with synchronization, is the waiting time. That is, If i want to go and get the lock, how long i wait in the order to get the lock? Contention: Un-scalability of lock is Contention. When so many thread waits to get a particular, and only one of them wins. Thats contention part of implementing synchronization primitive.Distributed System / Cloud ComputingDefinition: Distributed processing involves multiple processes on multiple systems. A distributed system is a collection of Nodes which are interconnected by a Local Area Network (LAN) or a Wide Area Network (WAN) and the LAN may be implemented using a twisted pair, coaxial cable and optical fiber, and if it is a WAN, it could be implemented using a satellite communication, microwave links and so on. That’s sort of the picture of What a distributed system is, number one.Memory Number two, there’s no physical memory that is shared between nodes of the distributed system. So the only way nodes can communicate with one another is by sending messages on the local area network to one another. So there is no shared memory (or physical memory) for communication between the nodes of the distributed system.Time Event Computation Time is the time it takes on a single node to do some meaningful processing, that computation time is what we are calling as the event computation time. And a node may also communicate With other nodes in the system and that’s what we’re calling as communication time or the messaging time. And the third property, is the fact that the message communication time is significantly larger than event computation time that happens on a single node.Reason A system is distributed if a message transmission time, is not negligible compared to the time between events in a single process.Example What is the implication of this definition? Interestingly, even a cluster is a distributed system by this definition. Because processors have become blazingly fast, so the event computation has shrunk quite a bit. On the other hand the message communication time is also becoming better but not as fast as the computation time that happens on a single processor and therefore even on a cluster which is all contained in a single rack in a data center, the message transmission time is significantly more than The event time. And so even a cluster is a distributed system by this definition.Benefits of Cloud Computing Reduced Cost Automatic Updates Green Benefits of Cloud computing Remote Access Disaster Relief Self-service provisioning Scalability Reliability and fault-tolerance Ease of Use Skills and ProficiencyHappy Reading :)" }, { "title": "Queue in swift", "url": "/posts/queue-in-swift/", "categories": "Notes", "tags": "swift", "date": "2016-03-05 09:41:10 +0400", "snippet": "Here, we’ll be creating a simple data structure Queue, to demonstrate some of the functionalities of swift language, which includes: Value-type generics, Secure memory pointers, Mutating functions on struct, Sequence Type and Generator Types protocols, and Copy-on-write feature on swiftQueue is an abstract data type or a linear data structure, in which the first element is inserted from one end called REAR (also called Tail), and the deletion of existing element takes place from the other end called as FRONT (also called Head). This makes queue as FIFO data structure, which means that element inserted first will also be removed first. Like Stack, Queue is also an ordered list of elements of similar data types. The process to add an element into queue is called Enqueue and the process of removal of an element from queue is called Dequeue.Queue ProtocolIt defines the functionality of Queue, having three functions `enqueue:`, `dequeue`, and `peek`. All functions are marked as `mutating` because they will be mutating the queue properties. Since it’ll be a homogenous queue we’ve associated the protocol with type `Element` which will be queued or dequeued.protocol QueueType { typealias Element mutating func enqueue(element: Element) mutating func dequeue() -&amp;gt; Element? func peek() -&amp;gt; Element?} Mutating By default, the properties of a value type (like struct or enum) cannot be modified from within its instance methods. However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to mutating behavior for that method. References: Apple Documentation, A blog post by @NatashaTheRobotQueue Storage:final class Storage {private var pointer: UnsafeMutablePointer private let capacity: Intinit(capacity: Int) { pointer = UnsafeMutablePointer.alloc(capacity) self.capacity = capacity }static func copy(storage: Storage) -&amp;gt; Storage { let storageNew = Storage(capacity: storage.capacity) storageNew.pointer.initializeFrom(storage.pointer, count: storage.capacity) return storageNew }func add(element: Element, at index: Int) { (pointer + index).initialize(element) }func removeAt(index: Int) { (pointer + index).destroy() }func itemAt(index: Int) -&amp;gt; Element { return (pointer + index).memory }deinit { pointer.destroy(capacity) pointer.dealloc(capacity) }}We’ll create a generic class to store queue elements in it. This class will initialize a mutable pointer with given capacity and will have functions like `add` and `remove` at given index.Functions:init(capacity: Int); It will allocate memory with capacity for pointer, which will keep queue elements. Here is a good explanation about Memory Pointers in swiftfunc add(element: Element, at index: Int) func removeAt(index: Int) func itemAt(index: Int) -&amp;gt; Element These functions will let us add, remove and return an element at a given position in the storage. Note: (ptr + position).memory works because of + is overloaded in swift’s stdlib which gives the pointer incremented by the number provided. `public func +(lhs: UnsafeMutablePointer, rhs: Int) -&amp;gt; UnsafeMutablePointer\\`deinit Swift doesn’t provide any option to do a cleanup when a value type is removed from a memory. So we need to use class as a storage, it gives deinit function where we can write the cleanup. deinit is called when a reference type is removed (A reference type is removed when there are zero references to it), we have to get rid of all the memory we asked for while creating this storage when our queue goes out of scope._**static func copy(storage: Storage) -&amp;gt; Storage**_ We’ll need to copy the storage when our queue is passed around and is mutated.The Queue:struct Queue : QueueType {private var storage: Storage private var rear: Int = 0 private var front: Int = 0 private var count: Int = 0 private let capacity: Intinit(capacity: Int) { self.capacity = capacity storage = Storage(capacity: capacity) }private mutating func makeUnique() { if !isUniquelyReferencedNonObjC(&amp;amp;storage) { storage = Storage.copy(storage) } }mutating func enqueue(element: Element) { guard count &amp;lt; capacity else { print(“Queue is full.”) return } makeUnique() storage.add(element, at: rear) rear = (rear + 1) % capacity count = count + 1 }mutating func dequeue() -&amp;gt; Element? { guard count &amp;gt; 0 else { print(“Queue is empty.”) return nil }makeUnique() let item = storage.itemAt(front) storage.removeAt(front) front = (front + 1) % capacity count = count - 1 return item }func peek() -&amp;gt; Element? { guard count &amp;gt; 0 else { print(“Queue is empty.”) return nil } return storage.itemAt(front) }}Queue is implemented as a struct containing five properties, storage keeps the buffer, rear and front keeps the track of Tail and Head of the queue respectively, count keeps the total number of elements and capacity defines total size of queue buffer. The init method will initialize storage with the provided capacity.Functions:private mutating func makeUnique() It keeps the common functionality of struct. It calls isUniquelyReferencedNonObjC() internally (a method defined in stdlib) which tells us if a non-objc object ie pure swift object has reference count equal to one or not.`public func isUniquelyReferencedNonObjC&amp;lt;T : AnyObject&amp;gt;(inout object: T) -&amp;gt; Bool`if !isUniquelyReferencedNonObjC(&amp;amp;storage) { storage = Storage.copy(storage)}so when one queue instance is assigned into another variable it will share the storage instance until enqueue, dequeue, or peek is called on the new instance (or the old one) and it will detach the old storage and create a new copy for itself to use by calling the copy method on the storage. This is how copy-on-write is achieved. Thanks @aciidb0mb3r for the clarification. Here is Doc and an example code which simplifies the same.enqueue() will insert an element at end of the queue. dequeue() will remove first element from the queue. peek() will return the first element of the queue.In order for queue to support for..in looping just like an array, It needs to implement SequenceType protocol. Here is the key is generate() function, which returns a GeneratorType. Thus we also need to implement the GeneratorType protocol, which makes a call to dequeue() function from next() function implementation. Reference: Swift Collection Protocolsextension Queue: SequenceType { func generate() -&amp;gt; QueueGenerator { return QueueGenerator(queue: self) }}struct QueueGenerator : GeneratorType { var queue: Queue mutating func next() -&amp;gt; Element? { return queue.dequeue() }}ExamplesLet’s try out queue with Int and also calls SequenceType’s functions to do operations on the queue.var intQueue = Queue(capacity: 20)intQueue.enqueue(11)intQueue.enqueue(12)intQueue.dequeue() // Remove from front ie 11intQueue.enqueue(13)print(&quot;Print elements in queue&quot;)for i in intQueue { print(i)}let queueValuesMultipliedByTwo = intQueue.map { $0 * 2 }print(queueValuesMultipliedByTwo)Storing reference type in QueueNow, let’s try the queue with reference types, we’ll create a simple class, which confirms to CustomStringConvertible protocol to print class description. And add few instances into the queue.class Foo : CustomStringConvertible { let tag: Int init(_ tag: Int) { self.tag = tag } deinit { print(“Removing…\\(tag)”) } var description: String { return “#\\(tag)” }}var queueClass = Queue(capacity: 20)queueClass.enqueue(Foo(1))queueClass.enqueue(Foo(2))queueClass.dequeue()print(queueClass)The entire playground friendly code is available here. Happy coding, cheers :)" }, { "title": "Interview Stuff", "url": "/posts/interview-stuff/", "categories": "technical-posts", "tags": "gcd, interview-questions, ios, ios-qa", "date": "2015-03-31 00:00:00 +0400", "snippet": "A list of interview topics for the developers, who are looking to hire or get hired for iOS work. These stuff are based on my experience while giving interviews or taking some for an iOS developer job. It also includes some self-test questions which have not been asked.__kindOf (Avoid compiler warnings for subclass access or to avoid casting) http://stackoverflow.com/a/31399395/559017Garbage Collector in Objective-C No, Objective C does not have GC, It does not scan heap for unused objects, no whole app pause, no deterministic release of any NS Object. Objective C used Manual Reference Counting until iOS 5 in terms of ‘retain’, ‘release’, and Automatic Reference Count in terms of ‘strong’, ‘weak’. https://mikeash.com/pyblog/friday-qa-2010-07-16-zeroing-weak-references-in-objective-c.htmlweak v/s assign The only difference between weak and assign is that if the object a weak property points to is deallocated, then the value of the weak pointer will be set to nil, so that you never run the risk of accessing garbage. If you use assign, that won’t happen, so if the object gets deallocated from under you and you try to access it, you will access garbage. weak does not work with primitive types like int, double. weak only works with ObjectiveC objects.Compiler directive? http://nshipster.com/at-compiler-directives/instancetype? http://nshipster.com/instancetype/ and http://stackoverflow.com/a/8976920NULL (void* 0), Nil (class 0), nil (id 0) and NSNull [NSNull null] http://nshipster.com/nil/Differentiate #import, #include and @class? #import: Improved version of include, brings entire header file into current file #include: With objective C, there is performance hit with #include, compiler must open up each header file to notice the include guard. @class: A forward declaration compiler directive, It tells the compiler that class exists, does not know anything about class. It minimizes the amount of code seen by the compiler or linker.Objective-C Variable Length Argument (var args). https://izeeshan.wordpress.com/2015/03/24/217/Method swizzling / Aspect Oriented Programming http://nshipster.com/method-swizzling/ https://github.com/steipete/AspectsObjective-C Collection Types and An array of weak objects. https://mikeash.com/pyblog/friday-qa-2010-05-28-leopard-collection-classes.html https://mikeash.com/pyblog/friday-qa-2012-03-09-lets-build-nsmutablearray.htmlDesign patterns. Thread Safe Singleton: https://izeeshan.wordpress.com/2014/08/31/threadsafe-singleton/ Facade - Wrapper on a complex system or apis. Decorator - Dynamically adds behaviors and responsibilities to an object without modifying its code, Ex. Category and Delegation (Modifies the behavior of an object instance.) Adapter - An Adapter allows classes with incompatible interfaces to work together. It wraps itself around an object and exposes a standard interface to interact with that object. Ex. NSCopying protocol implemented by so many, to provide standard copy method. Delegates and Datasources are examples of Adapter design pattern. Observer / Broadcasting Listeners - One object notifies other objects of any state changes. The objects involved don’t need to know about one another – thus encouraging a decoupled design. This pattern’s most often used to notify interested objects when a property has changed. Ex. NSNotification (Asynchronous message passing between two different objects) and KVO Memento - It captures and externalizes an object’s internal state. In other words, it saves your stuff somewhere. Later on, this externalized state can be restored without violating encapsulation; that is, private data remains private. Ex. NSUserDefaults and Archiving, unarchiving. Command - (Ex. Target-Action of a button) It encapsulates a request or action as an object. The encapsulated request is much more flexible than a raw request and can be passed between objects, stored for later, modified dynamically, or placed into a queue. Dependency Injection: A software design pattern that implements inversion of control for software libraries. Caller delegates to an external framework the control flow of discovering and importing a service or software module specified or “injected” by the caller.NSObject: the Class and the Protocol https://mikeash.com/pyblog/friday-qa-2013-10-25-nsobject-the-class-and-the-protocol.html Multiple root classes in objective c, need common rules. Protocol inheritance (can access all NSObject protocol functions if inherited).Explain: [self self], [self class], [self release]Objective-C Category, -dealloc and +load methods in category, category with library and frameworks. https://izeeshan.wordpress.com/2012/09/06/ios-category/ Properties: http://nshipster.com/associated-objects/ Dealloc: http://stackoverflow.com/questions/14708905/how-do-i-access-the-dealloc-method-in-a-class-category Linker Flags: http://stackoverflow.com/questions/2567498/objective-c-categories-in-static-library+load / +initialize http://stackoverflow.com/a/13326633/559017 https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.htmlIPA size: https://developer.apple.com/news/?id=02122015aNSAutoreleasePool: https://mikeash.com/pyblog/friday-qa-2011-09-02-lets-build-nsautoreleasepool.html If a pool is destroyed which is not at the top of the stack of pools, it also destroys the other pools which sit above it. In short, NSAutoreleasePool instances nest. drain vs release, NSAutoreleasePool: drain is same as release except it signals to the collector that this might be a good time to run a collection cycle.NSZombie: It’s a memory debugging aid. Specifically, when you set NSZombieEnabled then whenever an object reaches retain count 0, rather than begin deallocated it morphs itself into an NSZombie instance. Whenever such a zombie receives a message, it logs a warning rather than crashing or behaving in an unpredictable way.Why retainCount should never be used in shipping code. http://stackoverflow.com/a/4636477 Invoking a method on nil returns a zero 0 value. Best practices are implicit instructions to compiler.Core Data &amp;amp; Migration: https://izeeshan.wordpress.com/2014/11/10/core-data-migration/ CoreData- Transient property: http://davemeehan.com/technology/objective-c/core-data-transient-properties-on-nsmanagedobject __attribute__(()): http://stackoverflow.com/questions/2053029/how-exactly-does-attribute-constructor-workXML Parsers SAX: Simple API for XML; Its one where our code gets notified as the parser reads the xml tree (data). We construct the objects and keep the track of states. DOM: Document Object Model; It reads the entire document and builds the object in which we can query for different elements. NSXMLParser: Its a SAX parser written in Objective-C and is quite straightforward to use. libxml2: A C based API and an Open source library, which supports both SAX and DOM processing. One cooler feature of this library, as it can parse the data as it’s being read from network.Differences In SAX we get notified but in DOM we have to query for object. In SAX we construct the objects and keep the track of states but in DOM we get build objects and keys as elements. Memory: DOM usually require more memory than SAX, because it reads all the data at once and kept that in memory; this is something to consider when we deal with large documents.Web Services (WSDL / SOAP / AJAX) Web Service is like program-to-program communication over the Internet through XML. It provides a service, based on Operations, defined in its interface. It communicated between different language, different platforms. WSDL: Web Service provides a way to describe their interface in enough details, and that description is usually provided in an XML document called Web Service Description Language (WSDL). In web service we send XML and we receive XML as response. SOAP: Web Service exposes useful functionality to Web users through a standard web protocols. In most cases, the protocol used is SOAP. It stands for Simple Object Access Protocol. JWS: Java Web Service - JAX-WS stands for Java API for XML Web Service. JAX-WS is a technology for building web services and clients that communicate using XML. AJAX: AJAX stands for Asynchronous JavaScript and XML. It allows asynchronous communication between a client and server. It does not mandate that the end user must wait for processing a request.REST APIs? How is it differ from SOAP? Representational State Transfer v Simple Object Access Protocol. REST permits many different data formats where as SOAP only permits XML. REST better browser support (coz of JSON), better performance, scalability. REST reads can be cached, SOAP can not be. SOAP used for WS-Security, WS-Atomic Transaction, WS-Reliable Messaging, Supports ACID transactions.Opaque v Alpha: http://stackoverflow.com/a/8520656 A struct is a special C data type that encapsulates other pieces of data into a single cohesive unit. Like an object, but built into C.Coordinates v/s Drawing The coordinates of Core Graphics drawings start from the bottom-left corner, while UIKit global coordinates start from the top-left.NSPredicate v NSScanner: http://nshipster.com/nsscanner/Frame v Bound v Center Frame: A view’s frame (CGRect) is the position of its rectangle in the superview’s coordinate system. By default it starts at the top left. Bounds: A view’s bounds (CGRect) expresses a view rectangle in its own coordinate system. Center: A center is a CGPoint expressed in terms of the superview’s coordinate system and it determines the position of the exact center point of the view.Application States: Not Running: The app has not been launched or it has been terminated. Inactive: The app is in the foreground but not receiving events, Ex. User has locked the device with the app active. Active: The normal state of “In Use” for an app. Background: The app is no longer on-screen, but still executing the code. Suspended: The app is still resident in memory but is not executing code.BLOCK: Blocks are created on the stack Blocks can be copied to the heap Blocks have their own private const copies of stack variables (and pointers) Mutable stack variables and pointers must be declared with the __block keyword Blocks, Operations and Retain Cycles - http://conradstoll.com/blog/2013/1/19/blocks-operations-and-retain-cycles.html Docs: http://albertodebortoli.github.io/blog/2013/04/21/objective-c-blocks-under-the-hood/ docs: http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html http://ios-blog.co.uk/tutorials/programming-with-blocks-an-overview/ dispatch barrier: https://izeeshan.wordpress.com/2014/09/03/dispatch-barriers/ **dispatch_group:** http://amro.co/gcd-using-dispatch-groups-for-fun-and-profit https://www.mikeash.com/pyblog/friday-qa-2009-09-04-intro-to-grand-central-dispatch-part-ii-multi-core-performance.html http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2Multithreading: Sync v Async, Concurrency v Non-Concurrency, Parallel v Concurrency. https://izeeshan.wordpress.com/2014/08/17/multi-threading-using-nsoperation/Operating System: https://izeeshan.wordpress.com/2016/06/04/operating-system/Difference between +alloc and +allocWithZone : When one object creates another, it’s sometimes a good idea to make sure they’re both allocated from the same region of memory. The zone method (declared in the NSObject protocol) can be used for this purpose; it returns the zone where the receiver is located. (2014) Apple documentation says that the zone parameter is ignored, and “This method exists for historical reasons; memory zones are no longer used by Objective-C.”#TODO Network layers, SSL pinning Cryptography Public key v Private key:Other References NEVER MISS Whats New: https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html Cameron Banga Raywenderlich Blog NSHipster Quizzes http://bizzydevapps.weebly.com/ http://huntmyideas.weebly.com/blog/category/ios-interview-questions-and-answers https://horseshoe7.wordpress.com/2012/07/25/what-to-ask-an-ios-developer-at-their-interview/Thanks for reading.Feel free to add other links or questions in comments, Cheers!!" }, { "title": "why Swift", "url": "/posts/why-swift/", "categories": "", "tags": "objective-c, swift", "date": "2015-03-25 00:00:00 +0400", "snippet": "Why did Apple introduce new programming language Swift instead of embracing an existing one like Java, Python, C++ one that already has community, exiting developers, and lots of resources?First of all, Apple is very much notorious for ignoring what everyone else is doing, and heading off in their own direction if they think it’s the best solution.Objectives: To update Objective-C so that we can have a faster, easier, safer language without destroying Cocoa? To take advantage of the headway they have made with compiler technology. To achieve low level work, all the way down to the kernel if needed. Watch kit development. Last but not least, most important goal is interoperation, any replacement would have to work naturally with the existing frameworks.Currently on plate: Java belongs to someone else and needs a virtual machine. Apple already support C++ to some extent. Including making a connection between C++ and Cocoa. But replacing one complicated C-based language with an even more complicated C-based language would not result in progress. Ruby 2.1, on the other hand, does support keyword arguments that would work with Objective-C. In fact, Apple wrote this at one point—it was called MacRuby. Apple abandoned MacRuby, though, so apparently they weren’t happy with it. Neither Python or Ruby are compiled which rules them out.So they created Swift, which not only replaces Objective-C but also works with all existing frameworks naturally. And it isn’t particularly hard to learn. By creating their own language from the ground up, Apple is constrained by nothing but their own requirements and resources. Since their requirements are rather specific and their resources include one of the world’s best compiler teams, that’s a pretty good place to be.How swift is swift? Static Typing Value Types No pointer aliasing Constants Copy on writehttps://developer.apple.com/swift/" }, { "title": "Custom NSLog", "url": "/posts/custom-nslog/", "categories": "technical-posts", "tags": "c, fprintf, ios, nslog, objective-c, variable-length", "date": "2015-03-24 00:00:00 +0400", "snippet": "ZKLogWriting our own NSLog using c-function with variable length arguments.I’ve used fprintf() function to write on console, because it sends the formatted output to the stream, where printf() internally invokes fprintf() with stdout.stderr stands for standard error device. The benefit of doing this is that anything written to standard error is not buffered so it is immediately written to the screen and is useful for debugging.void ZKLog(NSString*msg,…) {   va_list arguments;  va_start(arguments, msg);  NSString* message = [[NSString alloc] initWithFormat:msg arguments:arguments]; va_end(arguments); fprintf(stderr, “\\n%s\\n”, [message UTF8String]); [message release]; message = nil; }" }, { "title": "Core Data Migration", "url": "/posts/core-data-migration/", "categories": "", "tags": "core-data, example-code, frameworks, ios, ios-library, iphone, migration, sqlite, xcode", "date": "2014-11-10 00:00:00 +0400", "snippet": "Core DataA framework which manages, where data is stored, how it is stored, data caching, and memory management. It provides APIs to handle our data like insertion, update, deletion and for data validation. Basically these core data APIs takes care of all data management rules of sqlite.When did it come? It was ported to the iPhone from Mac OS X with the 3.0 iPhone SDK release.Why Core Data?Why we might want to use Core Data with SQLite for storage over property lists, a custom XML format, or direct SQLite database access? Here we have some reasons: It allows developers to create and use a database, perform queries using SQL-less conditions (without SQLite). We interact with SQLite in Objective-C or in objects way. And we don’t have to worry about connections or managing the database schema. It’s basically a fully object-oriented API, to store data in a database. So we can say, Object oriented database on top of SQL database. The main benefit to this approach is that it reduces the development time and simplifies the process. It can reduce the memory overhead of our app, increase responsiveness, and save us from writing a lot of boilerplate code. Otherwise writing complex SQL queries and handling SQLite operations are very difficult.How does it work?There is a tool in Xcode, which we use for creating a visual mapping between the objects (actually NSManagedObject Subclasses) that we are gonna stored in our database, and then Core Data manages all the interaction in between.Once we have this visual mapping created in Xcode then we can create new objects, put them in the database, query for objects in the database which is having an SQL database behind it. Core Data manages all the communication behind the scenes, all we see is Object Oriented side of it.Core Data TermsA Model (Managed Object Model / xcdatamodeld)A model that has all tables information. It’s schema or a database schema - a collection of all the tables (Entities, Data Models) that we use in our application. NSManagedObjectModel is a class that contains definitions for each of the table objects (also called “Entities”) that we have in our database. Usually, we use the visual editor (xcdatamodeld) to set up what tables are in the database, what their columns, and how they relate to each other. However, we can do this with code too!A Sore (Persistent Store) - sqlite fileA file or a database file (with .sqlite extension) stored in our application’s document directory.A Coordinator (Persistent Store Coordinator)A coordinator, who first associate store (sqlite file) with model, then coordinates (mediate) between store(s) and context(s).It’s a database connection, where we set up the actual names and locations of what databases will be used to store the objects, and any time a managed object context needs to save something it goes through this single coordinator.A Context (Managed Object Context)The job of a context is to use coordinator to first retrieve model information, then save our data into store. A context without a coordinator is of no use as it cannot access a model except through a coordinator. Its primary responsibility is to manage a collection of managed objects.We can think of this as a “scratch pad” for objects that come from the database. It’s also the most important of the three for us, because we’ll be working with this the most. Basically, whenever we need to get objects, insert objects, or delete objects, we call methods on the managed object context (or at least most of the time!)Only a coordinator can access the model. Not context.Only a context can access the coordinator. Not Us.So, We access context.Problem &amp;amp; SolutionThe problem is we can’t add / remove / modify any column in any table at runtime. We can’t alter it by anyway once it’s shipped. And to do the same we need to create something called Migration. Or we can say, when we change our data model, then we also need to move the data in existing stores to new version — changing the store format is known as migration.When migration is required?The easiest answer to this common question is “when we need to make changes to the data model.” When the Managed Object Model (mom/xcdatamodel) does not match, a migration is REQUIRED (an instance of NSMigrationManager).How does it work?The migration process updates data created with a previous version of the Data Model to match the current Data Model. Before going into migration process, lets see how core data initialisation works.Initializing Core DataWe initialize our Core Data stack by calling Context (NSManagedObjectContext), and then context initiate the rest of the work. Initialises model with momd (compiled xcdatamodeld). Initialises persistent store coordinator with model. Add a store to persistent store coordinator. (Here Core Data checks for versioning.) Allocate the context, then sets the persistent store coordinator to it.When we encounter these steps, Core Data does a few things in-between just prior to adding the store to the coordinator. Core Data analyzes the store’s model version the one which we are passing to add into coordinator. It compares this version to the coordinator’s configured data model if there is already one configured earlier. If the store’s model version and the coordinator’s model version don’t match, then Core Data will perform a migration, when enabled. If migrations aren’t enabled, and the store is incompatible with the model, Core Data will simply not attach the store to the coordinator and specify an error with an appropriate reason code.The Migration ProcessTo start the migration process, Core Data needs the original data model (ver 1) and the destination model (ver 2). It uses these two versions to load or create a mapping model for the migration. Then It uses mapping model to convert data in ver 1 (in the original store) to data that it can store to ver 2 (in the new or destination store). Once Core Data determines the mapping model, the migration process can start in earnest.During migration, Core Data creates two stacks, one for the source store and one for the destination store. Core Data then fetches objects from the source stack and inserts the appropriate corresponding objects into the destination stack.Basically, Migrations happen in three steps: First, Core Data copies over all the objects from one data store to the next. Next, Core Data connects and relates all the objects according to the relationship mapping. Enforce any data validation in the destination model. Core Data disables destination model validation during the data copy.Changes that do not require Migration:Basically anything that doesn’t change the underlying SQLite backing store, including: Changing the name of an NSManagedObject subclass Adding or removing a transient property Making changes to the user info dictionary Changing validation rules.Requirements for the Migration Process:Migration of a persistent store is performed by an instance of NSMigrationManager. To migrate a store, the migration manager requires several things: The managed object model for the destination store. (This is the persistent store coordinator’s model.) A managed object model that it can use to open the existing store. Typically, a mapping model that defines a transformation from the source (the store’s) model to the destination model.You don’t need a mapping model if you’re able to use lightweight migration.Core Data Migration WaysPrimary ways to create a migration: Automatic (aka lightweight), Manual, and Custom code.But in reality, the migration process may involve one or more of these techniques.The golden rule when it comes to Core Data migrations is, choose lightweight whenever possible. Manual migrations and migrations requiring custom code are a magnitude more complex and memory intensive.NOTE - Core Data does not perform migration linearly. It’ll update the app with whatever available like ver 1 to ver 3.Types of Migrations:These are not official categories of migration. Lightweight migrations Manual migrations Custom manual migrations Fully manual migrationsLightweight migrations: A lightweight migration is Apple’s term for the migration with the least amount of work involved on your part. If you just make simple changes to your model (such as adding a new attribute to an entity), Core Data can perform automatic data migration, referred to as lightweight migration.Lightweight migration is fundamentally the same as ordinary migration, except that instead of you providing a mapping model, Core Data infers one from differences between the source and destination managed object models.Manual migrations: Manual migrations involve a little more work on our part. We need to specify how to map the old set of data onto the new set, but we get the benefit of an explicit mapping model file to configure. Setting up a mapping model in Xcode is much like setting up a data model, with similar GUI tools and some automation.Custom manual migrations: If the transformation (add/remove properties or entities to your existing model) is more complex, however, you might need to create a subclass of NSEntityMigrationPolicy to perform the transformation.This is level 3 of the migration complexity index. You still use a mapping model, but add to that custom code with the ability to also specify custom transformation logic on data. In this case, custom entity transformation logic involves creating an NSEntityMigrationPolicy subclass and performing custom transformations there.Fully manual migrations: Fully manual migrations are for those times when even specifying custom transformation logic isn’t enough to fully migrate data from one model version to another. In this case, custom version detection logic and custom handling of the migration process are necessary.Lightweight MigrationWhat lightweight migration can do.Lightweight migrations can handle the following changes: Adding or removing an entity, attribute, or relationship Making an attribute non-optional with a default value Making a non-optional attribute optional Renaming an entity or attribute using a renaming identifierEnable Lightweight Migrations -You need to pass a dictionary containing two keys to the options parameter of the method that adds the persistent store to the coordinator. These keys are: NSMigratePersistentStoresAutomaticallyOption – attempt to automatically migrate versioned stores NSInferMappingModelAutomaticallyOption – attempt to create the mapping model automaticallySteps - Open your .xcdatamodeld file Click on Editor in Menu Bar Select Add Model Version…. Add a new version of your model (the new group of datamodels added) Select the main file, open File Inspector (Right-Hand Panel) And under Model Version core data model select your new version of data model for current data model from drop down. That’s not all, We need to perform so-called “light migration” with code. Go to your Core Data stack manager and find where the persistentStoreCoordinator is being created. Find this line if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;amp;error]) Replace nil options value with @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES} (actually provided in the commented code in that method)Here you go, have fun!Manual MigrationIf you want to make a change to the new model that’s not supported by lightweight migrations, you need to create a mapping model. A mapping model needs a source and a destination data model. When you add a new version of your data model, you are asked to select the model on which it should be based.Adding a version to data models: Open your .xcdatamodeld file Click on Editor in Menu Bar Select Add Model Version…. Add a new version of your model (the new group of datamodels added) Select the main file, open File Inspector (Right-Hand Panel) And under Model Version core data model select your new version of data model for current data model from drop down. Make the desired changes in Newly created Data Models (xcdatamodel file).Adding a mapping model for versions: Select New, File… from File menu on menu bar. Select Core Data from left panel and Mapping Model from right options then click Next. Select Source Data Model (Version 1) from list of xcdatamodel files then click Next. Choose Target Data Model (Destination or Next Version) from same list of xcdatamodel files then click Next.Now, let’s perform Manual Migration with Code Go to your Core Data stack manager and find where the persistentStoreCoordinator is being created. Find this line if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;amp;error]) Replace nil options value with @{NSInferMappingModelAutomaticallyOption:@YES}.Is migration needed? Migration is needed if destinationModel is NOT compatible with store meta data. Let’s check the same. Get metadata for source store from its url with given type (NSSQLiteStoreType). Get the destination managed object model from xcdatamodeld url. Call ‘compatible with store meta data’ function on destination managed object model. It returns bool value. We need migration if above function returns false.- (BOOL)isMigrationNeeded { NSError *error = nil; NSDictionary *sourceMetadata = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType URL:[self sourceStoreURL] error:&amp;amp;error]; BOOL isMigrationNeeded = NO; if (sourceMetadata != nil) { NSManagedObjectModel *destinationModel = [self managedObjectModel];// Migration is needed if destinationModel is NOT compatible isMigrationNeeded = ![destinationModel isConfiguration:nil compatibleWithStoreMetadata:sourceMetadata]; }   NSLog(@”isMigrationNeeded: %@”, (isMigrationNeeded == YES) ? @”YES” : @”NO”); return isMigrationNeeded;}The Migration Method Get metadata for source store from its url with given type (NSSQLiteStoreType). Create managed object model from source meta data. Get the destination managed object model from xcdatamodeld url. Get Mapping Model from bundle with source and destination managed object model. Create a destination store url (a different sqlite file path). Initialise a Migration Manager with source and destination managed object model. Now, NSMigrationManager can infer the mapping model between two models. So, call a migrate store function on manager with mapping model from source store url to destination store url. Remove old store file(s) (shm or wal) and then copy the destination store url to old source store location.- (BOOL)migrate {    NSURL *sourceUrl = [self sourceStoreURL]; // 1. Get metadata for source store from its URL with given type.    NSError *error = nil; NSDictionary *sourceMetadata = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType URL:sourceUrl error:&amp;amp;error];     if (sourceMetadata == NO) { NSLog(@”FAILED to create source meta data”);         return NO;    }// 2. Create model from source store meta deta. NSManagedObjectModel *sourceModel = [NSManagedObjectModel mergedModelFromBundles:@[[NSBundle mainBundle]] forStoreMetadata:sourceMetadata];    if (sourceModel == nil) { NSLog(@”FAILED to create source model, something wrong with source xcdatamodel.”);         return NO;    }// 3. Get the destination managed object model from xcdatamodeld url.     NSManagedObjectModel \\*destinationModel = \\[self managedObjectModel\\];// 4. Get Mapping model from bundle with source and destination managed object model. NSMappingModel \\*mappingModel = \\[NSMappingModel mappingModelFromBundles:@\\[\\[NSBundle mainBundle\\]\\] forSourceModel:sourceModel destinationModel:destinationModel\\];// 5. Create the destination store url (a different sqlite/database file path) NSString *fileName = @”ZKManualMigration_V2.sqlite”; NSURL *destinationStoreURL =  [[[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject] URLByAppendingPathComponent:fileName]; // 6. Migrate from source to latest matched destination model,    NSMigrationManager *manager = [[NSMigrationManager alloc] initWithSourceModel:sourceModel destinationModel:destinationModel];    BOOL didMigrate = [manager migrateStoreFromURL:sourceUrl                                              type:NSSQLiteStoreType                                         options:nil                                 withMappingModel:mappingModel                                  toDestinationURL:destinationStoreURL                                   destinationType:NSSQLiteStoreType                                destinationOptions:nil                                             error:&amp;amp;error];    if (!didMigrate) {        return NO;    }    NSLog(@”Migrating from source: %@ ===To=== %@”, sourceUrl.path, destinationStoreURL.path); // 7. Delete old sqlite file    NSError *err = nil; NSFileManager *fm = [NSFileManager defaultManager];     if (![fm removeItemAtURL:sourceUrl error:&amp;amp;err]) { NSLog(@”File delete failed.”);         return NO;    }    NSString *str1 = [NSString stringWithFormat:@”%@-shm”,sourceUrl.path]; [fm removeItemAtURL:[NSURL fileURLWithPath:str1] error:&amp;amp;err];     str1 = [NSString stringWithFormat:@”%@-wal”,sourceUrl.path]; [fm removeItemAtURL:[NSURL fileURLWithPath:str1] error:&amp;amp;err]; // Copy into new location    if (![fm moveItemAtURL:destinationStoreURL toURL:sourceUrl error:&amp;amp;err]) { NSLog(@”File move failed.”);         return NO;    }NSLog(@”Migration successful”);     return didMigrate;} Sample project on Manual Migration.Thanks for reading, cheers… 👍" }, { "title": "Handling Shared Resources using Dispatch Barriers", "url": "/posts/dispatch-barriers/", "categories": "technical-posts", "tags": "blocks, gcd, ios, max-os-x, multiple-threads, multithreading, objective-c, threads", "date": "2014-09-03 00:00:00 +0400", "snippet": "Handling Thread-Unsafe Shared ResourceIn the last post, we have discussed about creating thread-safe singleton objects. But creating a thread-safe singleton does not solve all the issues. If your singleton object uses any mutable object like NSMutableArray, then you need to consider whether that object is itself thread-safe or not. There is a misconception that the Foundation framework is thread-safe and the Application / UI Kit framework is not. Unfortunately, this is somewhat misleading. Each framework has areas that are thread-safe and areas that are not thread-safe. Apple maintains a helpful list of the numerous Foundation framework classes which are not thread-safe.The ProblemLets take an example, we have a class DocumentManager, which manages all our document read, write handling. And the DocumentManager class has been implemented as a singleton. This singleton object uses a NSMutableArray property for keeping all the document names, which is a Thread-Unsafe class. In DocumentManager, we have two functions addDocumentName and allDocs. Although many threads can read an instance of NSMutableArray simultaneously without issue, It’s not safe to let one thread modify the array while another is reading it. Our singleton doesn’t prevent this condition from happening in its current state. To see the problem, have a look at code, which has been reproduced below:- (void)addDocumentName:(NSString*)docName { if (docName) [_arrDocs addObject:docName];}This is a write method, which modifies the mutable array object by adding a document name into it. Now take a look at getter method:- (NSArray*)allDocs { return [NSArray arrayWithArray:_arrDocs];}This is a read method as it’s reading the mutable array property. It makes an immutable copy for the caller in order to defend against the caller mutating the array inappropriately, but none of this provides any protection against one thread calling the the write method addDocumentName: while simultaneously another thread calls the read method allDocs. This is the classic software development Readers-Writers Problem. GCD provides an elegant solution of creating a Readers-writer lock using dispatch barriers.Dispatch BarriersIt allows you to make thread-unsafe object to thread-safe. It creates a synchronisation point for a code block executing in a concurrent dispatch queue. Dispatch barriers are a group of functions acting as a serial queue style objects when working with concurrent queues. Using GCD’s barrier API ensures that the submitted block is the only item executed on the specified queue for that particular time. This means that all items submitted to the queue prior to the dispatch barrier must complete before the block will execute. When the block’s turn arrives, the barrier executes the block and ensures that the queue does not execute any other blocks during that time. Once finished, the queue returns to its default implementation. GCD provides both synchronous and asynchronous barrier functions. The diagram below illustrates the effect of barrier functions on various asynchronous blocks:[caption id=”attachment_178” align=”aligncenter” width=”660”] Execution of Dispatch Barrier[/caption]Notice how in normal operation the queue acts just like a normal concurrent queue. But when the barrier is executing, it essentially acts like a serial queue. That is, the barrier is the only thing executing. After the barrier finishes, the queue goes back to being a normal concurrent queue. Here’s when you would - and wouldn’t - use barrier functions: Custom Serial Queue: A bad choice here; barriers won’t do anything helpful since a serial queue executes one operation at a time anyway. Global Concurrent Queue: Use caution here; this probably isn’t the best idea since other systems might be using the queues and you don’t want to monopolise them for your own purposes. Custom Concurrent Queue: This is a great choice for atomic or critical areas of code. Anything you’re setting or instantiating that needs to be thread safe is a great candidate for a barrier.Since the only decent choice above is the custom concurrent queue, you’ll need to create one of your own to handle your barrier function and separate the read and write functions. The concurrent queue will allow multiple read operations simultaneously. Creating a custom concurrent queue is easy: just pass DISPATCH_QUEUE_CONCURRENT to the dispatch_queue_create function. Open your singleton class, and add the following private property to the class extension category:@property (nonatomic, strong) dispatch_queue_t concurrentDocumentQueue;Now replace addDocumentName function with below implementation:- (void)addDocumentName:(NSString*)docName { if (docName) { // 1 dispatch_barrier_async(self. concurrentDocumentQueue, ^{ // 2 [_arrDocs addObject:docName]; // 3 }); } }Here’s how your new write function works: Check that there’s a valid document name before performing all the following work. Add the write operation using your custom queue. When the critical section executes at a later time this will be the only item in your queue to execute. This is the actual code which adds the object to the array. Since it’s a barrier block, this block will never run simultaneously with any other block in concurrentDocumentQueue.This takes care of the write method, but we also need to implement the allDocs read method and instantiate concurrentDocumentQueue. To ensure thread safety with the writer side of matters, you need to perform the read on the concurrentDocumentQueue queue. You need to return from the function though, so you can’t dispatch asynchronously to the queue because that wouldn’t necessarily run before the reader function returns. In this case, dispatch_sync would be an excellent candidate. dispatch_sync() synchronously submits work and waits for it to be completed before returning. Use dispatch_sync to track of your work with dispatch barriers, or when you need to wait for the operation to finish before you can use the data processed by the block. If you’re working with the second case, you’ll sometimes see a __block variable written outside of the dispatch_sync scope in order to use the processed object returned outside the dispatch_sync function. You need to be careful though. Imagine if you call dispatch_sync and target the current queue you’re already running on. This will result in a deadlock because the call will wait to until the block finishes, but the block can’t finish (it can’t even start!) until the currently executing task is finished, which can’t! This should force you to be conscious of which queue you’re calling from” as well as which queue you’re passing in. Here’s a quick overview of when and where to use dispatch_sync: Custom Serial Queue: Be VERY careful in this situation; if you’re running in a queue and call dispatch_sync targeting the same queue, you will definitely create a deadlock. Main Queue (Serial): Be VERY careful for the same reasons as above; this situation also has potential for a deadlock condition. Concurrent Queue: This is a good candidate to sync work through dispatch barriers or when waiting for a task to complete so you can perform further processing.Now replace allDocs method with the following implementation:- (NSArray*)allDocs { __block NSArray *array; // 1 dispatch_sync(self.concurrentDocumentQueue, ^{ // 2 array = [NSArray arrayWithArray:_arrDocs]; // 3 }); return array;}Here’s your read function. Taking each numbered comment in turn, you’ll find the following: The __block keyword allows objects to be mutable inside a block. Without this, array would be read-only inside the block and your code wouldn’t even compile. Dispatch synchronously onto the concurrentDocumentQueue to perform the read. Store the document array in array and return it.Finally, you need to instantiate your concurrentDocumentQueue property. Since we are working on a singleton class, so we will make the changes in the sharedManager function so that it instantiate only once. Change sharedManager method to instantiate the custom concurrent queue like so:+ (instancetype)sharedManager { static DocumentManager *sharedDocumentManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ sharedDocumentManager = [[DocumentManager alloc] init]; sharedDocumentManager-&amp;gt;_arrDocs = [NSMutableArray array]; // ADD THIS: sharedDocumentManager-&amp;gt;_concurrentDocumentQueue = dispatch_queue_create(“com.mycompany.ThreadySafety.documentQueue”,DISPATCH_QUEUE_CONCURRENT);  }); return sharedDocumentManager;}This initialises concurrentDocumentQueue as a concurrent queue using dispatch_queue_create. The first parameter is a reversed DNS style naming convention; make sure it’s descriptive since this can be helpful when debugging. The second parameter specifies whether you want your queue to be serial or concurrent. Note: When searching for examples on the web, you’ll often see people pass 0 or NULL as the second parameter of dispatch_queue_create. This is a dated way of creating a serial dispatch queue; it’s always better to be specific with your parameters. Your mutable property now thread safe. No matter where or how you read or write this property, you can be confident that it will be done in a safe manner with no amusing surprises.You can download the source code which contains all the code snippet used in this post. Some parts of this post is derived from Ray Wenderlich Tutorials. Thanks for reading. :)" }, { "title": "Is your Singleton Thread-Safe?", "url": "/posts/threadsafe-singleton/", "categories": "technical-posts", "tags": "ios, multithreading, threads", "date": "2014-08-31 00:00:00 +0400", "snippet": "First, lets have a look into the concepts of some Terminologies:SingletonA singleton class returns the same instance no matter how many times an application requests it. A typical class permits callers to create as many instances of the class as they want, whereas with a singleton class, there can be only one instance of the class per process. A singleton object provides a global point of access to the resources of its class. Singletons are used in situations where this single point of control is desirable, such as with classes that offer some general service or resource.Thread-SafeThread safe code can be safely called from multiple threads or concurrent tasks without causing any problems (data corruption, crashing, etc). Code that is not thread safe must only be run in one context at a time. An example of thread safe code is NSArray. You can use it from multiple threads at the same time without issue. On the other hand, NSMutableArray is not thread safe and should only be accessed from one thread at a time.Context SwitchA context switch is the process of storing and restoring execution state (context) of a process or thread, when we switch between executing different threads on a single core (single process). So that the execution can be resumed from the same point at a later time. This enables multiple processes to share a single CPU and is an essential feature of a multitasking operating system. It’s like switching from one thread (process) to another.Creating Thread-Safe SingletonsSingletons, A very popular design pattern in every technology. One frequent concern with singletons is that often they’re not thread safe. This concern is well-justified given their use: singletons are often used from multiple controllers accessing the singleton instance at the same time.Lets take an example, we have a class DocumentManager, which manages all our document read, write handling. And the DocumentManager class has been implemented as a singleton. To see how things can go wrong really quickly, we’ll create a controlled race condition on the singleton instance.The current sharedManager function looks like the code below: (instancetype)sharedManager   {     static DocumentManager * sharedDocumentManager = nil;     if (!sharedDocumentManager) {         sharedDocumentManager = [[DocumentManager alloc] init];         NSLog(@”Singleton has memory address at: %@”, sharedDocumentManager);     }     return sharedDocumentManager; }The code is rather simple in its current state; we create a singleton. However, the if condition branch is not thread safe; if we invoke this method multiple times, there’s a possibility that one thread (call it Thread-A) could enter the if block and a context switch could occur before sharedDocumentManager is allocated. Then another thread (Thread-B) could enter the if, allocate an instance of the singleton, then exit.When the system context switches back to Thread-A, we’ll then allocate another instance of the singleton, then exit. At that point we have two instances of a singleton — which is not what we want!To force this condition to happen, replace sharedManager function in DocumentManager.m with the following implementation: (instancetype)sharedManager   {     static DocumentManager * sharedDocumentManager = nil;     if (!sharedDocumentManager) {         [NSThread sleepForTimeInterval:2];         sharedDocumentManager = [[DocumentManager alloc] init];         NSLog(@”Singleton memory address: %@”, sharedDocumentManager);         [NSThread sleepForTimeInterval:2];     }     return sharedDocumentManager; }In the code above we’re forcing a context switch to happen with NSThread’s sleepForTimeInterval: class method.Now make a call to sharedManager function, for doing the same, Open AppDelegate.m and add the following code to the very beginning of application:didFinishLaunchingWithOptions:dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{         [DocumentManager sharedManager];});     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{         [DocumentManager sharedManager];});This creates multiple asynchronous concurrent calls to instantiate the singleton and invoke the race condition as described above.Build and run our project; check the console output and we’ll see multiple singletons instantiated, as shown below:[caption id=”attachment_165” align=”aligncenter” width=”772”] Console Output: Thread-Unsafe Singleton object address.[/caption]Notice that there are several lines all showing different addresses of the singleton instance. That defeats the purpose of a singleton, doesn’t it? :)This output shows we that the critical section executed several times when it should have only have executed once. Now, admittedly, we forced this situation to happen, but we can imagine how this condition could occur unintentionally as well.Note: Based upon other system events beyond our control, a variable amount of NSLogs will show up on occasion. Threading issues can be extremely hard to debug since they tend to be hard to reproduce.To correct this condition, the instantiation code should only execute once and block other instances from running while it is in the critical section of the if condition. This is exactly what dispatch_once does.Replace the conditional if check with dispatch_once in the singleton initialisation method as shown below:+ (instancetype)sharedManager   {     static DocumentManager * sharedDocumentManager = nil;     static dispatch_once_t onceToken;     dispatch_once(&amp;amp;onceToken, ^{        [NSThread sleepForTimeInterval:2];         sharedDocumentManager = [[DocumentManager alloc] init];         NSLog(@”Singleton memory address: %@”, sharedDocumentManager);         [NSThread sleepForTimeInterval:2];     });     return sharedDocumentManager; }Build and run our app; check the console output and we’ll now see one and only one instantiation of the singleton — which is what we’d expect for a singleton! :)Now that we understand the importance of preventing race conditions, replace DocumentManager’s singleton initialisation with the following implementation:+ (instancetype)sharedManager   {     static DocumentManager * sharedDocumentManager = nil;     static dispatch_once_t onceToken;     dispatch_once(&amp;amp;onceToken, ^{         sharedDocumentManager = [[DocumentManager alloc] init];         NSLog(@”Singleton memory address: %@”, sharedDocumentManager);     });     return sharedDocumentManager;}dispatch_once() executes a block once and only once in a thread safe manner. Different threads that try to access the critical section — the code passed to dispatch_once — while a thread is already in this section are blocked until the critical section completes.It should be noted that this just makes access to the shared instance thread safe. It does not make the class thread safe, necessarily. We could still have other critical sections in the class, for instance anything that manipulates internal data. Those would need to be made thread safe in other ways, such as synchronising access to the data.Thanks for reading. :)Some parts of this post is derived from Ray Wenderlich Tutorials." }, { "title": "Local HTTP Server for iOS", "url": "/posts/local-http-server-for-ios/", "categories": "technical-posts", "tags": "cocoa-http-server, http-server, ios, localhost, max-os-x, networking", "date": "2014-08-25 00:00:00 +0400", "snippet": "Problem (Features)Yeah, because what I feel is, everything starts with a Problem, when we face problems, issues. We put our thoughts, we start to work on it, we come up with some solutions, we build something. Thats what we do. Right? Since we are in IT field, we are always into trouble :], so many problems, so many issues, we solve one another comes up, sometimes they are so many. A big nerd have said once:“A Software is always work in progress…”So lets start with some problems which going to be our features of our final product. Here we’ll be discussing only about client server based issue, as where we work the most.Client Demo – Problem comes when we have to demo our app to the client, what if server is down in that particular time. How we going to present our app? We’ll place dummy data here and there and then we’ll put so many if conditional blocks in our code to read from those dummy data instead of hitting web services. Right? We are not going to do that from now on.Slow Network Connectivity – How do we test the slow network connectivity? Some people use our app with 3G/LTE network, some don’t. Some use it with WIFI or lets say 2G network. We always have to make sure that our application should work in every possible condition. It should show proper message, irrespective of network reachability.Mandatory Fields Check – Generally when we write client server application we deal with so many GET/POST http header fields or post body fields. In which some are mandatory and some fields are non mandatory. For mandatory fields every time we have test it with server and wait for the response. What if the server has confirmed some mandatory fields and they have implemented it? Or our application might get stuck if we do not implement a mandatory field and server respond to it on production.Large Image / Video Upload – How do we make sure that your application is sending image/video data correctly.Data Formatting and Validation – GET/POST body data validation and formatting, JSON/XML validation or Email/DOB validation checks.Random Error Probability – How our application behaves when server sends some error randomly. Its pretty interesting, the thought about Error Probability is like receiving errors from server randomly and seeing how our application is responding to it.UI Refreshing – This is what we should always take care of, because this is what the end user deals with, here is what the experience they get.Session Setup – If you want to check, when the server starts and ends the session.Proxy ServerAnd here comes the Proxy Server (Local Host/127.0.0.1). Its HTTP, because it is one of the simpler protocols to implement for communication between computers. Since there is no APIs for Stubbed data downloading or data synchronisation; embedding a Proxy server in your application, is one of the best ways to transfer data from our local host to our iOS / Mac OS X applications. It’s an asynchronous networking using GCD and standard sockets programming between our local host and iOS applications. Here, I’ll show you how to write your own simple but extensible HTTP server for iOS applications. The server classes will also work on Mac OS X.How to configureIts pretty simple to configure HTTP Server. You’ll see those couple of lines of code to do the same. We only have to start a socket and attach a listener to it. It includes just four steps, that’s it. It is just a tiny HTTP server but the approach will allow you to quickly integrate HTTP communications into any application. Start Server - Open a Socket Receive Incoming Connections Response Handling Stop Server - Close SocketFramework NeededJust three frameworks needed to start with and those are:#import &amp;lt;sys/socket.h&amp;gt; //For #defines like AF_INET protocol family.#import &amp;lt;netinet/in.h&amp;gt; //Socket address structure and others defined parameter values.#import &amp;lt;CFNetwork/CFNetwork.h&amp;gt; //Core Network APIs (need to add into project).Opening a SocketMost server communications, HTTP included, begin by creating a socket for listening. Sockets in Cocoa can be created and configured entirely using the CoreFoundation CFSocket API. It easier — But we still have a large block of boilerplate code to throw down just to open a socket.Create Socket object:CFSocketRef socket = CFSocketCreate(kCFAllocatorDefault, PF_INET, SOCK_STREAM, IPPROTO_TCP, 0, NULL, NULL);CFSocketCreate creates a CFSocket object of a specified protocol and type. Here we pass the parameters of protocol family, stream socket and TCP protocol. kCFAllocatorDefault is used for current default allocator.Get Native Socket:int reuse = true;int fileDescriptor = CFSocketGetNative(socket);setsockopt(fileDescriptor, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;amp;reuse, sizeof(int));CFSocketGetNative returns the native socket associated with a CFSocket object. If CFSocket object has been invalidated, it returns -1 (INVALID_SOCKET).Bind Socket to address:struct sockaddr_in address;memset(&amp;amp;address, 0, sizeof(address));address.sin_len = sizeof(address);address.sin_family = AF_INET;address.sin_addr.s_addr = htonl(INADDR_ANY);NSInteger portNumber = 8080;address.sin_port = htons(portNumber);CFDataRef addressData = CFDataCreate(NULL, (const UInt8 *)&amp;amp;address, sizeof(address));CFSocketSetAddress(socket, addressData);sockaddr_in is a C structure for socket address parameters like socket address, port number and etc. We create a CFData object containing a struct sockaddr appropriate for the protocol family of socket object (struct sockaddr_in or struct sockaddr_in6, for example). This data object is used only for the duration of the function call.CFSocketSetAddress binds a local address to a CFSocket object and configures it for listening. This function binds the socket by calling bind, and if the socket supports it, configures the socket for listening by calling listen with a backlog of 256. Once the socket object is bound to address, depending on the socket’s protocol, other processes and computers can connect to socket object. It returns an error code indicating success or failure.Receive Incoming NotificationSo, we are done with opening a socket to listen for TCP connections on the port specified by HTTP_SERVER_PORT (which was 8080). After the socket is setup, Cocoa handles a little more of the work so things get easier. Cocoa does a pretty good job for us by invoking an incoming connection notification, we only have to register a listener to it by constructing a file handler from native socket object. We can receive each incoming connection by constructing an NSFileHandle from the fileDescriptor above and listening for connection notifications.Constructing File HandlerNSFileHandle *listeningHandle = [[NSFileHandle alloc] initWithFileDescriptor:fileDescriptor closeOnDealloc:YES];[listeningHandle acceptConnectionInBackgroundAndNotify];initWithFileDescriptor initialises and returns a file handle object associated with the specified POSIX file descriptor and deallocation policy. If flag is NO, the file descriptor you pass in to this method is not owned by the file handle object. In such a case, you are responsible for closing the file descriptor at some point after disposing of the file handle object. If you want the file handle object to close the descriptor for you automatically, pass YES for the flag parameter.Attach Connection Listener[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(receiveIncomingConnectionNotification:) name:NSFileHandleConnectionAcceptedNotification object:nil];Receive File HandlerNSDictionary *userInfo = [notification userInfo];NSFileHandle *incomingFileHandle = [userInfo objectForKey:NSFileHandleNotificationFileHandleItem];NSFileHandleNotificationFileHandleItem is a key in the user info dictionary in a NSFileHandleConnectionAcceptedNotification notification. The corresponding value is the NSFileHandle object representing the “near” end of a socket connection.Attach Incoming Data Listener[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(receiveIncomingDataNotification:) name:NSFileHandleDataAvailableNotification object:incomingFileHandle]; [incomingFileHandle waitForDataInBackgroundAndNotify];Then we attach another listener with this DataFileHandler for incoming data. NSFileHandleDataAvailableNotification, this notification is posted when the file handle determines that data is currently available for reading in a file or at a communications channel. The notification object is the NSFileHandle object that sent the notification. This notification does not contain a userInfo dictionary instead it contains availableData for that connection.Two file handlers[caption id=”attachment_143” align=”aligncenter” width=”646”] Two file handlers on Local HTTP Server[/caption]When receiveIncomingConnectionNotification: function is invoked, each new incoming connection will get its own NSFileHandle. If you’re keeping track, that was: 1 file handle (listeningHandle) manually created from the socket fileDesriptor to listen on the socket for new connections, a Connection Listening file handler. 1 file handle automatically created for each new connection received through listeningHandle. We’ll continue to listen to these new handles (the keys in the incomingRequests dictionary) to record the data for each connection, a Data Listening file handler for listing to available data on stream.Receive Incoming DataHandle Incoming DataNSFileHandle *incomingFileHandle = [notification object];NSData *data = [incomingFileHandle availableData];Create HTTP Message to store dateCFHTTPMessageRef incomingRequest = CFHTTPMessageCreateEmpty(kCFAllocatorDefault, TRUE);CFHTTPMessageAppendBytes(incomingRequest, [data bytes], [data length]);So, we’ve received a new, automatically created file handle. Now we’ll create a CFHTTPMessageRef to store the incoming data we receive over the file handle. We store these as the objects in incomingRequests dictionary to allow easy access to the CFHTTPMessageRef for each file handle. CFHTTPMessageCreateEmpty creates and returns a new, empty CFHTTPMessage object then we call CFHTTPMessageAppendBytes to store an incoming serialised HTTP request message in the empty message object.CFHTTPMessageAppendBytes function appends the data specified by newBytes to the specified message object which was created by calling CFHTTPMessageCreateEmpty. The data is an incoming serialised HTTP request or response received from a client or a server. While appending the data, this function deserialises it, removes any HTTP-based formatting that the message may contain, and stores the message in the message object. You can then call CFHTTPMessageCopyVersion, CFHTTPMessageCopyBody, CFHTTPMessageCopyHeaderFieldValue, and CFHTTPMessageCopyAllHeaderFields to get the message’s HTTP version, the message’s body, a specific header field, and all of the message’s headers, respectively.If the message is a request, you can also call CFHTTPMessageCopyRequestURL and CFHTTPMessageCopyRequestMethod to get the message’s request URL and request method, respectively.If the message is a response, you can also call CFHTTPMessageGetResponseStatusCode and CFHTTPMessageCopyResponseStatusLine to get the message’s status code and status line, respectively.The CFHTTPMessageRef is both storage and the parser for the incoming data. We can invoke CFHTTPMessageIsHeaderComplete() every time we add data to check when the HTTP headers are complete and we can spawn a response handler. The response handler is spawned in the receiveIncomingDataNotification method. The server stops listening to the file handle for the connection at this point but it doesn’t close it, since the file handle is passed to the response handler so that the HTTP response can be sent back over the same file handle.Sample Incoming DataGET / HTTP/1.1Host: 127.0.0.1:8080Accept-Encoding: gzip, deflateAccept: text/html,application/xhtml+xml,application/xml;q=0.9,/*;q=0.8User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10) AppleWebKit/538.34.48 (KHTML, like Gecko) Version/8.0 Safari/538.35.8Accept-Language: en-usDNT: 1Connection: keep-aliveHandling ResponseParsing Request DataNSURL *requestURL = NSMakeCollectable(CFHTTPMessageCopyRequestURL(ref));NSString *httpMethod = NSMakeCollectable(CFHTTPMessageCopyRequestMethod(ref));NSDictionary *httpHeaderFields = NSMakeCollectable(CFHTTPMessageCopyAllHeaderFields(ref));NSData *httpBody = NSMakeCollectable(CFHTTPMessageCopyBody(ref));Now we can parse the HTTP request body, NSMakeCollectable makes a newly allocated Core Foundation object an NSObject which is eligible for collection. This function is a wrapper for CFMakeCollectable, but its return type is id—avoiding the need for casting when using Cocoa objects. This function may be useful when returning Core Foundation objects in code.Create HTTP ResponseNSInteger responseCode = 200;CFHTTPMessageRef response = CFHTTPMessageCreateResponse(kCFAllocatorDefault, responseCode, NULL, kCFHTTPVersion1_1);Begin sending a response over the fileHandle. Trivial cases can synchronously return a response but everything else should spawn a thread or otherwise asynchronously start returning the response data.CFHTTPMessageCreateResponse() creates and returns a CFHTTPMessage object for an HTTP response. This function returns a CFHTTPMessage object that you can use to build an HTTP response. Then call CFHTTPMessageCopySerializedMessage() to make the message ready for transmission by serialising it.Add Response header fieldsCFHTTPMessageSetHeaderFieldValue(response, (CFStringRef)@”Content-Type”, (CFStringRef)@”text/plain”);CFHTTPMessageSetHeaderFieldValue(response, (CFStringRef)@”Connection”, (CFStringRef)@”close”);We can call CFHTTPMessageSetHeaderFieldValue() function to set the message’s headers, CFHTTPMessageSetHeaderFieldValue() sets the value of a header field in an HTTP message, and calling CFHTTPMessageSetBody() to set the message’s body.Add Data Length in header fieldsNSString *dataLength = [NSString stringWithFormat:@”%d”, fileData.length];CFHTTPMessageSetHeaderFieldValue(response, (CFStringRef)@”Content-Length”, (CFStringRef)dataLength);Serialise HTTP Response in DataCFDataRef headerData = CFHTTPMessageCopySerializedMessage(response);CFHTTPMessageCopySerializedMessage() serialises a CFHTTPMessage object. This function returns a copy of a CFHTTPMessage object in serialised format that is ready for transmission. It creates a self-contained copy of a CFHTTPMessage. This would be suitable for persistent storage or for transmitting over the network independently.Sending ResponseWrite HTTP Header Data and Response Data[incomingFileHandle writeData:(NSData*)headerData];[incomingFleHandle writeData:fileData];Close file handler and Remove Listeners[incomingFileHandle closeFile];[[NSNotificationCenter defaultCenter] removeObserver:self name:NSFileHandleDataAvailableNotification object:incomingFileHandle];Stop ServerRemove Connection Listener[[NSNotificationCenter defaultCenter] removeObserver:self name:NSFileHandleConnectionAcceptedNotification object:nil];Close Socket[listeningHandle closeFile];CFSocketInvalidate(socket);CFRelease(socket);CFSocketInvalidate() invalidates a CFSocket object, stopping it from sending or receiving any more messages.You should always invalidate a socket object when you are through using it. Invalidating a CFSocket object prevents the object from sending or receiving any more messages, but does not release the socket object itself.If a run loop source was created for s, the run loop source is invalidated.If a release callback was specified in CFSocketContext object, this function calls it to release the object in the info field (which was provided when s was created).By default, this call closes the underlying socket. If you have explicitly cleared the kCFSocketCloseOnInvalidate flag by calling CFSocketSetSocketFlags, you must close the socket yourself after calling this function.Configure In AppStart Serverfunc application(application: UIApplication!, didFinishLaunchingWithOptions launchOptions: NSDictionary!) -&amp;gt; Boolfunc applicationWillEnterForeground(application: UIApplication!)Stop Serverfunc applicationDidEnterBackground(application: UIApplication!)Normally there’s no need to run our server on any specific port. Technologies like Bonjour allow clients to dynamically discover the server’s port at runtime. However, for easy testing you may want force a certain port so you can just hit the refresh button.There is no public (allowed in AppStore) method for iOS to run continuously in the background for our purposes (serving HTTP). So, we stop the server when the app is paused (if a users exits from the app or locks a device) and restart the server when the app is resumed (based on this document: http://developer.apple.com/library/ios/#technotes/tn2277/_index.html )Solutions Set up Core Data or SQLite for dynamic tables Add delay before Response Handling Configure Error Probability On Response Configure Session Setup Add Server States (Idle / Running) Add Configurations like Port no, etc…Set up Core Data for any specific project because you cannot add dynamic tables to it. In this case you only have to populate the core data with dummy responses.You can also build a layer of SQLite for dynamic tables. This will make your dummy server more scalable. Which can help others as well.Delay – You can add delays ask users to set the delay property for proxy server. This will help you to test slow network connectivity.Error Probability – Create a property which will count for all your requests. You can increase counter when some one hit your server and then respond with error response in specific counter value lets say for all even or all odd.Session setup – you can anytime configure it.Server State – Its good for end user and for server writer as well to keep the state of your server. Whether its in Idle or running state.Other Configurations – Like Port no. which can define any specific port no. Which will prevent others to guess.References http://www.cocoawithlove.com/2009/07/simple-extensible-http-server-in-cocoa.html https://github.com/robbiehanson/CocoaHTTPServer https://developer.apple.com/library/ios/technotes/tn2277/_index.htmlSample ProjectYou can also find the presentation on it, Proxy Server PPTThanks for reading! :)" }, { "title": "Thread Safe vs Thread Un-Safe", "url": "/posts/thread-safe-vs-thread-un-safe/", "categories": "technical-posts", "tags": "multithreading, nsoperation, nsthread, posix, threads", "date": "2014-08-18 00:00:00 +0400", "snippet": "Thread safe and Thread un-safe objects: Thread safe objects are safe to pass from one thread to another. On the other hand you may get stale value if you try to access a thread unsafe object with multiple threads. A non thread safe (thread unsafe) API is one where you can not interact with multiple threads simultaneously. If something is described as “not thread safe”, it means that no special precautions have been taken to ensure that it won’t crash when two separate threads try to use it simultaneously. In general, code that is to be used by more than one thread requires explicit locks (or @synchronize blocks) wrapping around the code. In particular, If two threads try to write any object or variable at the same time can cause a crash (since they’d be writing to the same memory address.) Similarly, if one thread was reading a variable while another was writing to it, garbage would be returned and the program would likely crash. Using @synchronized, or NSLock or a POSIX mutex etc, ensures that only one thread can execute a particular block of code at any given time. The other threads get blocked and have to wait until the lock is released. There is a slight performance hit with using locks. An API is only thread safe if the documentation explicitly claims thread safety. If there is no mention of thread safety, you must assume that the API is not thread safe.An atomic property in Objective C guarantees that you will never see partial writes. When a @property has the attribute atomic it is impossible to only partially write the value. The setter/getter would be like:- (void)setMyName:(NSString*)name { @synchronized(self){ _myName = name; }} (NSString*)myName { @synchronized(self){ return _myName; }}Threading Programming Guide - Apple DocsProgramming with Objective C - Apple Docs" }, { "title": "Multi-Threading using NSOperation", "url": "/posts/multi-threading-using-nsoperation/", "categories": "technical-posts", "tags": "multithreading, nsoperation, nsthread, posix, threads", "date": "2014-08-17 00:00:00 +0400", "snippet": "Recently I had given couple of presentations on Multithreading using NSOperations and GCD. Here is the first draft of transcript.CPU (Central Processing Unit)WHY I’m starting from here, because everything happens here only. But this is not the reason, The reason is to start from here is that how earlier days of computing works?Before going into the threads, lets go into initial days of computing, then we’ll try to solve some questions like: What do we understand by Cores like single core, dual core, octa core systems? How does these came into existences? What are the problem we faced before building this? How does it effect our system?Clock SpeedThe Clock Speed (of CPU) is used to determine the maximum amount of wok a computer (CPU) can perform in a specific time (a time unit). So we can say, our system executes our programs with x clock speed.Problems: Because the day after day technology is getting advance, So design of processor which takes cares of our task getting compact and complex. So many constraints started to come when we were working with ONE processor, and started to limit out the maximum clock speed of processors. So the designer looked for other ways to increase the total performance of their chips.Solution: The solution is, they settled on increasing the number of processor cores on each chip. By increasing the number of cores, a single chip could execute more instructions per second without increasing the CPU speed (Clock Speed) or changing the chip size or other thermal characteristics.Another Problem: So we have understood about the need of cores, now the next thing is How to use these cores? How to take advantage of the extra cores? We have n number of cores now… This means they can execute our instructions simultaneously. If we have two different task then they can executed parallel. So we need a software now, A software that can use these cores and perform task simultaneously or can do multiple things parallel.ThreadHere comes the Threads, We have multitasking operating systems like OS X or iOS which has got the thread APIs to work with these cores.From a technical standpoint, a thread is a combination of the kernel-level and application-level coding (data structure), which is needed to manage the execution of code or a task. The kernel-level structures coordinate the dispatching of events to the thread and the preemptive scheduling of the thread on one of the available cores. The application-level structures include the call stack for storing function calls and the structures the application needs to manage and manipulate the thread’s attributes and state.Having multiple threads in an application provides two very important potential advantages: Multiple threads can improve an application’s perceived responsiveness. Multiple threads can improve an application’s real-time performance on multicore systems.With multicore computers common these days, threads provide a way to increase performance in some types of applications. Threads that perform different tasks can do so simultaneously on different processor cores, making it possible for an application to increase the amount of work it does in a given amount of time.Threads let us solve two tricky problems: Parallel computation — In this world of multicore CPUs, many tasks will run faster if you divide the work between threads that are scheduled on different cores. This approach can be useful even on a single core system. Specifically, if your computation thread spends some fraction of its time blocked (for example, waiting for disk I/O), you can use multiple threads to do useful computation on one thread while the other thread is blocked. Asynchronous computation — If you have some long-running computation to do and, as is the case on iOS, you must keep the main thread responsive, you can move that computation to a secondary thread. This allows your main thread to treat the computation as it would any other asynchronous operation.A common approach is to use the NSThread API directly, or perhaps take advantage of Cocoa’s- performSelectorInBackground:withObject: method.NSThread: (The traditional Way) Cocoa implements threads using the NSThread class, Foundation framework contains this class. Cocoa also provides methods on NSObject for spawning new threads and executing code on already-running threads. Based on POSIX ‘Portable Operating System Interface’ threading APIs (Pthreads), now a days every thread is POSIX Mac OS X (Mavericks) is 100% POSIX compliant.Hazards of threaded programmingHowever, threads are not always the right solution. Threads have a significant cost, in terms of both memory and, more importantly, code complexity.Problem will arise when you increase number of cores in your system. Why, because our threaded code does not scale vary well, to arbitrary numbers of cores. We cannot create as many threads as there are cores and expect a program to run well. Its very challenging for an application to compute your task that can use available number of cores in your system efficiently. Even if you manage to do so, to get the numbers correct, there is still a challenge to run these many thread efficiently and keeping them from interfering with one another.Although threads have been around for many years and continue to have their uses, they do not solve the general problem of executing multiple tasks in a scalable way. With threads, the actual burden of creating a scalable solution rests squarely on the shoulders of you, the developer. UIKit Access: Code ends up calling UIKit on a secondary thread, which is not allowed. DB Access: Not calling database function on same thread (Creating DB on main, then executing on another may cause you crash) Stale Result: Accessing a property with multiple threads leaves the user interface showing stale results. Cancellation: It would be nice if we could stop a thread, which needs to be discarded, so that it doesn’t waste CPU cycles, battery life, and memory. Thread-safe De-allocation: If you run any threaded code within UIKit objects (such as a view controller, where the -dealloc method typically releases UIView objects), there’s a chance that the object’s –dealloc method will be called on a secondary thread.Solutions - Lets summarize the problem: There must be a way for an app to take advantage of multiple cores. And Solution has to be simple:  provides the solution of all these problems. Operations (NSOperationQueue) GCD (Grand Central Dispatch) Notification queue  (addObserverForName:object:queue:usingBlock:) Asynchronous (NSURLConnections, NSURLSessions) Timers (NSTimer) Separate ProcessesIn many cases it’s a good idea to use the asynchronous APIs available in iOS instead. Periodic execution — Starting a thread just to execute code periodically is never a good idea. You should use NSTimer instead. Networking — On a typical iOS device, the CPU is much faster than the network so, if you start a thread to do your networking synchronously, that thread will spend most of its time blocked. A better approach is to use the asynchronous networking APIs provided by iOS.NSOperationsAn abstract class comes to the rescue! NSOperation and NSOperationQueue are higher level classes that have greatly simplified the process of dealing with multiple threads. Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. We typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads. We only need to focus on business logic, rest NSOperation does it. It make sure our business logic works correctly with other system objects. It encapsulates (executes) the code and data associated with a single task. Because it is abstract, we do not use this class directly but instead subclass or use one of the system-defined subclasses (NSInvocationOperation or NSBlockOperation) to perform the actual task. An operation object is a single-shot object—that is, it executes its task once and cannot be used to execute it again. And It’s a Thread Safe class.NSOperations FeaturesManage Thread Lifecycle: NSOperation is the one way to manage your threaded code, it takes care of the whole lifecycle of a thread from thread creation to destruction. It provides the infrastructure for solving all of the problems discussed above.Asynchronous: NSOperation is a class that allows you to model asynchronous operations in a structured fashion. It Encapsulate a unit of work in an object asynchronously. It provides a way for the high-level parts of your application to start asynchronous operations without worrying about the details of how they are executed. Operation objects are non-concurrent by default.KVO Compliant Properties:The NSOperation class is key-value coding (KVC) and key-value observing (KVO) compliant for several of its properties. As needed, you can observe these properties to control other parts of your application. The properties you can observe include the following: isCancelled - read-only property isConcurrent - read-only property isExecuting - read-only property isFinished - read-only property isReady - read-only property dependencies - read-only property queuePriority - readable and writable property completionBlock - readable and writable propertyOperation Dependencies:Dependencies are a convenient way to execute operations in a specific order. You can make operations dependent on other operations, and thereby establish chains of operation execution and operation fan in. You can add and remove dependencies for an operation using the addDependency: and removeDependency: methods. By default, an operation object that has dependencies is not considered ready until all of its dependent operation objects have finished executing. Once the last dependent operation finishes, however, the operation object becomes ready and able to execute. The dependencies supported by NSOperation make no distinction about whether a dependent operation finished successfully or unsuccessfully. (In other words, canceling an operation similarly marks it as finished.) It is up to you to determine whether an operation with dependencies should proceed in cases where its dependent operations were cancelled or did not complete their task successfully. This may require you to incorporate some additional error tracking capabilities into your operation objects. Any operation can be dependent on any number of operations. When you make operation A dependent on operation B, even though you call “start” on operation A, it will not start unless operation B isFinished is true. For example:DownloadOperation *downloadOp = [[DownloadOperation alloc] init]; // DownloadOperation is a subclass of NSOperationFilterOperation *filterOp = [[MyFilterOperation alloc] init]; // FilterOperation is a subclass of NSOperation [filterOp addDependency:downloadOp]; // To remove dependencies: [filterOp removeDependency:downloadOp];Priority:Sometimes the operation you wish to run in the background is not crucial and can be performed at a lower priority. You set the priority of an operation by using “setQueuePriority:”.[filterOp setQueuePriority:NSOperationQueuePriorityVeryLow];Other options for thread priority are: NSOperationQueuePriorityLow, NSOperationQueuePriorityNormal, NSOperationQueuePriorityHigh, and NSOperationQueuePriorityVeryHigh.When you add operations to a queue, the NSOperationQueue looks through all of the operations, before calling “start” on them. Those that have higher priorities will be executed first. Operations with the same priority will be executed in order of submission to the queue (FIFO).Completion block:Another useful method in NSOperation class is setCompletionBlock:. If there is something that you want to do once the operation has been completed, you can put it in a block and pass it into this method. Note that there is no guarantee the block will be executed on the main thread.[filterOp setCompletionBlock: ^{ NSLog(@”Finished filtering an image.”);}]; Thread Confinement:NSOperation encourages a programming model called Thread Confinement. In this model the resources used by the thread are owned by that thread, not shared between threads, where you can still specify priorities and manage dependencies between operations.Cancellation:An operation can also be canceled. Canceling an operation object leaves the object in the queue but notifies the object that it should abort its task as quickly as possible. For currently executing operations, this means that the operation object’s work code must check the cancellation state, stop what it is doing, and mark itself as finished. In OS X v10.6 and later, canceling an operation causes the operation to ignore any dependencies it may have. This behavior makes it possible for the queue to execute the operation’s start method as soon as possible. The start method, in turn, moves the operation to the finished state so that it can be removed from the queue.Concurrent vs Non-Concurrent Operations:NSOperation objects are non-concurrent by default. But If you plan on executing an operation object manually, instead of adding it to a queue, you can design your operation to execute in a concurrent or non-concurrent manner.In a non-concurrent operation, the operation’s task is performed synchronously—that is, the operation object does not create a separate thread on which to run the task. Thus, when you call the start method of a non-concurrent operation directly from your code, the operation executes immediately in the current thread. By the time the start method of such an object returns control to the caller, the task itself is complete.A concurrent operation runs asynchronously. In other words, when you call the start method of a concurrent operation, that method could return before the corresponding task is completed. This might happen because the operation object created a new thread to execute the task or because the operation called an asynchronous function.Note: In OS X v10.6, operation queues ignore the value returned by isConcurrent and always call the start method of your operation from a separate thread. In OS X v10.5, however, operation queues create a thread only if isConcurrent returns NO. In general, if you are always using operations with an operation queue, there is no reason to make them concurrent.A good example of a concurrent operation is one that executes an HTTP request using the NSURLConnection API.Notes on NSOperation (Caveats) A finished operation cannot be restarted. You cannot reuse an operation. Once it is added to a queue, you give up ownership. If you want to use the same operation class again, you must create a new instance. If you cancel an operation, it will not happen instantly. It will happen at some point in the future when someone explicitly checks for isCancelled == YES in “main”; otherwise, the operation will run until it is done. Always check for the isCancelled property frequently. You don’t want to run a operation in the background if it is no longer required!NSOperationQueueNSOperationQueue also has a fairly simple interface. It is even simpler than NSOperation, because you don’t need to subclass it, or override any method — you simply create one. It is a good practice to give your queue a name; this way you can identify your operation queues at run time and make it debugging easier.NSOperationsQueue FeaturesADD Operations:The NSOperationQueue class regulates the execution of a set of NSOperation objects. Each operation is executed by an operation queue (NSOperationQueue). As soon as an operation is added to a queue, you should relinquish ownership by sending a release message to the operation object (if using manual reference counting, no ARC), and the queue will then assume responsibility to start the operation. At this point, it is up to the queue as to when it will call “start”.DownloadOperation *downloadOp = [[DownloadOperation alloc] init]; [myQueue addOperation:downloadOp];[downloadOp release]; // Manual Reference CountingREADY &amp;amp; EXECUTE Operations: An operation object is not considered ready to execute until all of its dependent operations have finished executing. Operations within the queue (but not yet executing) are themselves organized according to priority levels and inter-operation object dependencies and are executed accordingly. An operation queue executes its queued operation objects based on their priority and readiness. If all of the queued operation objects have the same priority and are ready to execute when they are put in the queue—that is, their isReady method returns YES—they are executed in the order in which they were submitted to the queue (FIFO).PENDING Operations:At any time you can ask a queue which operations are in the queue, and how many operations there are in total. Remember that only those operations that are waiting to be executed, and those that are running, are kept in the queue. As soon as an operation is done, it is gone from the queue.NSArray *active_and_pending_operations = myQueue.operations;NSInteger count_of_operations = myQueue.operationCount;MULTIPLE Queues:An application may create multiple operation queues and submit operations to any of them. You can create operation queues to model your problem space. For example, a file copying program could use one operation queue per disk to avoid thrashing the disk head.THREADS &amp;amp; QUEUESA queue is not the same thing as thread. A queue can have multiple threads. Each operation within a queue is running on its own thread. Take the example where you create one queue, and add three operations to it. The queue will launch three separate threads, and run all operations concurrently on their own threads.How many threads will be created? That’s a good question! :) It depends on the hardware. By default, NSOperationQueue class will do some magic behind the scenes, decide what is best for the particular platform the code is running on, and will launch the maximum possible number of threads.Consider the following example. Assume the system is idle, and there are lots of resources available, so NSOperationQueue could launch something like eight simultaneous threads. Next time you run the program, the system could be busy with other unrelated operations which are consuming resources, and NSOperationQueue will only launch two simultaneous threads.Queue Width:Each queue has a maximum number of operations that it will execute in parallel / concurrently (maxConcurrentOperationCount), commonly known as the Queue Width. This width defaults to a value that’s appropriate for the device on which you’re running, but you can set it to a value that’s appropriate for the task at hand. For example, you can guarantee that operations are serialized (executed one at a time) by setting the queue width to 1. Or, if your operations hit the network, you can use the queue width to limit the number of concurrent network operations.NSOperationQueue may choose to run any number of concurrent operations, but it won’t be more than the maximum.myQueue.MaxConcurrentOperationCount = 3;If you change your mind, and want to set MaxConcurrentOperationCount back to its default, you would perform the following changes:myQueue.MaxConcurrentOperationCount = NSOperationQueueDefaultMaxConcurrentOperationCount;Serial Queue: For a queue whose maximum number of concurrent operations is set to 1, this equates to a Serial Queue. However, you should never rely on the serial execution of operation objects. Changes in the readiness of an operation can change the resulting execution order.Pause (Suspend) Queue:We can pause a queue by setting setSuspended:YES. This will suspend all operations in a queue — you can’t suspend operations individually. To resume the queue, simply setSuspended:NO.// Suspend a queue [myQueue setSuspended:YES]; // Resume a queue[myQueue setSuspended: NO];CANCEL Operations:After being added to a queue, an operation remains in that queue until it is explicitly canceled or finishes executing its task. To cancel all operations in a queue, you simply call “cancelAllOperations”. The reason is that cancelAllOperations doesn’t do much, except that it calls “cancel” on every operation in the queue — it doesn’t do anything magical! :)If an operation has not yet started, and you call “cancel” on it, the operation will be cancelled and removed from the queue. However, if an operation is already executing, it is up to that individual operation to recognize the cancellation (by checking the isCancelled property) and stop what it is doing.[myQueue cancelAllOperations];KVO-Compliant PropertiesThe NSOperationQueue class is key-value coding (KVC) and key-value observing (KVO) compliant. You can observe these properties as desired to control other parts of your application. The properties you can observe include the following: operations - read-only property operationCount - read-only property maxConcurrentOperationCount - readable and writable property suspended - readable and writable property name - readable and writable propertyAlthough you can attach observers to these properties, you should not use Cocoa bindings to bind them to elements of your application’s user interface. Code associated with your user interface typically must execute only in your application’s main thread. However, KVO notifications associated with an operation queue may occur in any thread.Add Operation With Block:If you have a simple operation that does not need to be subclassed, you can simply pass it into a queue by way of a block. If you want to send any data back from the block, remember that you should not pass into the block any strong reference pointers; instead, you must use a weak reference. Also, if you want to do something that is related to the UI in the block, you must do it on the main thread:UIImage *myImage = nil;// Create a weak reference__weak UIImage *myImage_weak = myImage;// Add an operation as a block to a queue[myQueue addOperationWithBlock: ^ { // a block of operation NSURL *aURL = [NSURL URLWithString:@”http://www.somewhere.com/image.png”]; NSError *error = nil; NSData *data = [NSData dataWithContentsOfURL:aURL options:nil error:&amp;amp;error]; If (!error) [myImage_weak imageWithData:data]; // Get hold of main queue (main thread) [[NSOperationQueue mainQueue] addOperationWithBlock: ^ { myImageView.imag e = myImage_weak; // updating UI  }]; }];Presentation PPT and Sample CodeThanks for reading :)Second draft of presentation is on its way… stay tuned!!" }, { "title": "NSRunLoop understanding", "url": "/posts/nsrunloop-understanding/", "categories": "technical-posts", "tags": "nsrunloop, nsthread, runloops", "date": "2014-07-22 00:00:00 +0400", "snippet": "NSRunLoop (A wrapper of CFRunLoop)Nothing but a loop or a event processing loop, where your thread enters, where it runs event handlers for incoming events. They handle (manage/monitor) input sources (input devices) like keyboard, mouse events from window system. They also observe objects like NSPort, NSConnection (NSTimer events).How runloop works: It takes all input events, Keeps them in runloop stack, Fires one at a time, Gives events to handlers to process (input data as events, callback methods as handlers for Connection object), Waits till that event gets completed, Once complete return back to runloop stack, Check for another event to process, If none is there goes to sleep.- Basically, It sends asynchronous callbacks to handlers, if we don’t want remove / invalidate object from runloop. - They must be associated at least one mode, because modes determines what event should processed. - Scheduling a run loop source doesn’t allow the source’s callbacks to run concurrently with other source’s callbacks.Thread and NSRunLoop Our application can not create or explicitly manage NSRunLoop objects. Each thread (NSThread) object has its own NSRunLoop object (automatically created). Even main thread has its own NSRunLoop object (automatically created). There is exactly one run loop per thread. You neither create nor destroy a thread’s run loop.Thread Safety NSRunLoop is Not Thread Safe means will not return to loop until one process gets completed. NSRunLoop’s methods should only be called within the context of the current thread. We should NEVER call the methods of NSRunLoop object running in a different thread (might cause unexpected results).Some book notes: A run loop is a piece of infrastructure used to manage events arriving asynchronously on a thread. A run loop works by monitoring one or more event sources for the thread. As events arrive, the system wakes up the thread and dispatches the events to the run loop, which then dispatches them to the handlers you specify. If no events are present and ready to be handled, the run loop puts the thread to sleep. Run loops make it possible to create long-lived threads that use a minimal amount of resources. Because a run loop puts its thread to sleep when there is nothing to do, it eliminates the need for polling, which wastes CPU cycles and prevents the processor itself from sleeping and saving power. To configure a run loop, all you have to do is launch your thread, get a reference to the run loop object, install your event handlers, and tell the run loop to run. Every thread has one and only one run loop. Each run loop, and hence each thread, however, has its own set of input modes that determine which input sources are listened to when the run loop is run. The input modes defined in one run loop do not affect the input modes defined in another run loop, even though they may have the same name. Despite some outward appearances, the NSRunLoop class is not thread safe. You should call the instance methods of this class only from the thread that owns it. Run loop mode A collection of input sources, timer sources, and run loop observers associated with a particular name. When run in a specific “mode,” a run loop monitors only the sources and observers associated with that mode. If you have some kind of user interface, or other code that needs to listen to events like network ports, you need a run loop. In general, your application does not need to either create or explicitly manage NSRunLoop objects. Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.Key TermsSynchronization Tool One of the hazards of threaded programming is resource contention among multiple threads. If multiple threads try to use or modify the same resource at the same time, problems can occur. One way to alleviate the problem is to eliminate the shared resource altogether and make sure each thread has its own distinct set of resources on which to operate. Another way is to synchronize access to the resource using locks, conditions, atomic operations, and other techniques. Best way is to use @synchronized(object) {Everything will be protected here.} block. It’s a way to acquire lock for given object, no other thread can acquire if one is already have it.Mutex / Locks Locks provide a brute force form of protection for code that can be executed by only one thread at a time. The most common type of lock is mutual exclusion lock, also known as a mutex. A lock that provides mutually exclusive access to a shared resource. A mutex lock can be held by only one thread at a time. Attempting to acquire a mutex held by a different thread puts the current thread to sleep until the lock is finally acquired. When a thread tries to acquire a mutex that is currently held by another thread, it blocks until the lock is released by the other thread.Semaphore A protected variable that restricts access to a shared resource. Mutex and Conditions are both different types of semaphore.Thread: A separate path of execution for code. Process: A running executable, which can encompass multiple threads. Task: The abstract concept of work that need to be performed.References:Apple Guide, Class Reference, Concurrent Programming Guide" }, { "title": "Dismiss Keyboard From iPad Model View Controller", "url": "/posts/dismiss-keyboard-from-ipad-model-view-controller/", "categories": "technical-posts", "tags": "ios, ipad, view-controllers", "date": "2012-11-19 00:00:00 +0400", "snippet": "When you have a view controller under navigation controller presented as model view then you have to add a method (given below) into navigation controller through categories.- (BOOL)disablesAutomaticKeyboardDismissal { return NO; }" }, { "title": "Change Navigation Bar Title Properties", "url": "/posts/change-navigation-bar-title-properties/", "categories": "technical-posts", "tags": "ios, uilabel, uinavigationbar, view-controllers", "date": "2012-11-19 00:00:00 +0400", "snippet": "NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:[UIFont fontWithName:@”Arial” size:22],UITextAttributeFont,[UIColor whiteColor], UITextAttributeTextColor,[UIColor grayColor], UITextAttributeTextShadowColor,[NSValue valueWithUIOffset:UIOffsetMake(-1, 0)], UITextAttributeTextShadowOffset,nil];self.navigationController.navigationBar.titleTextAttributes = dic;ORAdd UILabel to titleViewApple Doc" }, { "title": "NSAssert in iOS", "url": "/posts/nsassert-in-ios/", "categories": "technical-posts", "tags": "assertion-handler, ios, nsassert", "date": "2012-09-13 00:00:00 +0400", "snippet": "Assertion is a defence against programming errors. It tests a condition, and if the condition fails, it raises an exception. This is processed by the current exception handler, which by default call abort and crashes the program. iOS calls abort by default, which terminates the program no matter what thread it runs on.NSAssert is a macro, which evaluates the conditions and serves as a front end to the assertion handler.Each thread has its own assertion handler, which is an object of class NSAssertionHandler. When invoked, an assertion handler prints an error message that includes the method and class names. It then raises an NSInternalInconsistencyException exception. If condition evaluates to NO, the macro invokes handleFailureInMethod:object:file:lineNumber:description: on the assertion handler for the current thread, passing desc as the description string. This macro should be used only within Objective-C methods. We should use Exceptions for error condition which come from the outside (outside the method or outside the program) like parameter checking or missing/defective external resources like files or connections or user input. We should use Assertions to indicate an internal defects like programming errors, conditions that shouldn’t occur, e.g. class/method invariants and invalid program state.NSAssert(someCondition, @&quot;Print this statement.&quot;); Assert is to make sure a value is what its suppose to be. If assertion fails that means something went wrong and so the app quits. One reason to use assert would be if you have some function that will not behave or will create very bad side effects if one of the parameters passed to it is not exactly some value (or a range of values) you can put an assert to make sure that value is what you expect it to be, and if its not then something is really wrong, and so the app quits. Assert can be very useful for debugging/unit testing, and also when you provide frameworks to stop the users from doing “evil” thingsYou should take out NSAssert for release. This is debatable. I always release my applications with assertions enabled, and this is standard practice for a lot of software, Apple for example does this. As soon as your program has detected an abnormal state you should crash. You can get a stack trace of where the error occurred, whereas if you disable asserts you could end up corrupting memory and/or user data and the problem will be very hard to debug.Note that XCode 4 has NS_BLOCK_ASSERTIONS defined by default in release configurations. I guess if you don’t change that your released code will not contain NSAssertReferences: NSAssertionHandler Class Reference http://stackoverflow.com/questions/1375786/whats-the-point-of-nsassert-actually" }, { "title": "iOS Protocols", "url": "/posts/ios-protocols/", "categories": "technical-posts", "tags": "ios", "date": "2012-09-06 00:00:00 +0400", "snippet": "Protocols in Objective C is a Class from which structure is inherited, not implementation.A protocol is means to define a list of required and/or optional methods that a class implements. If a class adopts a protocol, it must implement all required methods in the protocols it adopts. Since Objective-C does not support multiple inheritances, you can achieve similar functionality with protocols, as a class can adopt more than one protocol. A good example of a protocol is NSCoding, which has two required methods that a class must implement. This protocol is used to enable classes to be encoded and decoded, that is, archiving of objects by writing to permanent storage.Protocol in Objective C is like an Interface in Java.Some default protocols: UIAlertViewDelegate, UIActionSheetDelegate, UIImagePickerControllerDelegate, UIWebViewDelegate, Table View DataSource etc." }, { "title": "iOS Memory", "url": "/posts/ios-memory/", "categories": "", "tags": "", "date": "2012-09-06 00:00:00 +0400", "snippet": "Object Ownership:1. Object creation: alloc, init, new, copy, 2. Take Ownership: retain 3. must relinquish ownership of objects we own. 4. must not relinquish ownership of objects we do not own. Retain Count:1. when we create an object: retain count is 1. 2. when we retain an object: retain count is incremented by 1. 3. when w release an object: retain count is decremented by 1. 4. when we autorelease an object: retain count is decremented by 1 at some stage in the future. 5. when we assign nil to an object: retain count is 0. 6. when an object’s retain count is reduced to 0, it is deallocated.Remove from collection: whenever we remove any object from any collection class, it is sent a release (rather than autorelease) message. Parent removal:Incorrect: NSString *str = [arr objectAtIndex:0]; [arr release]; or [arr removeObjectAtIndex:0]; or arr = nil; //using str object here Correct: NSString *str = [[arr objectAtIndex:0] retain]; [arr release]; or [arr removeObjectAtIndex:0]; or arr = nil; //using str object here [str release];Deallocating an object: When any object’s retain count drops to 0, that object’s memory is reclaimed - in cocoa terminology it is freed or deallocated. when an object is deallocated, its dealloc method is invoked automatically. The role of the dealloc method is to free the object’s own memory, and dispose of any resources it holds, including ownership of any object instance variables. If your class has object instance variables that it owns, you must implement a dealloc method that releases them, and then after releasing instance variables invokes super’s implementation. - (void)dealloc { [instanceVar release]; [super dealloc]; }Circular reference: Parent object retains the child reference and child reference retains the parent’s object.Weak Reference to ObjectAn object can not be deallocated until all of its strong references are released.A weak reference is created by storing a pointer to an object without retaining the object.why it is needed: Weak references are essential in cases where a circular reference would otherwise be set up. For example, if Object A and Object B communicate with each other, each needs a reference to the other. If each retains the other, neither object ever gets deallocated until the connection is broken, but the connection is not broken until one of the objects is deallocated. Catch-22. To break the circle, one object takes a subordinate role and obtains a weak reference to the other. As a concrete example, in a view hierarchy, a parent view owns, and hence retains, its child views, but a child view does not own its parent; the child still needs to know who its parent is, so it keeps a weak reference to its parent.Example of weak reference: NSNotification. Manipulation of reference count (retain count) [ take and relinquish ownership]1. alloc or newAllocates memory for an object, and returns it with retain count of 1. We own objects we create using any method that starts with the word alloc or with the word new.2. copyMakes a copy of an object, and return it with retain count of 1. If we copy an object, we own the copy. This applies to any method that contains the word copy where copy refers to the object being returned.3. retainIncrease the retain count of an object by 1. Takes ownership of an object.4. releaseDecrease the retain count of an object by 1. Relinquishes ownership of an object.5. autoreleaseDecrease the reference count of an object by 1 at some stage in the future. Relinquishes ownership of an object at some stage in the future. The only places you shouldnít use accessor methods to set an instance variable are in init methods and dealloc. How does collection handles object’s ownership:When we add an object to a collection such as an array, dictionary, or set, the collection takes ownership of it. The collection will relinquish ownership when the object is removed from the collection or when the collection is itself released." }, { "title": "iOS Delegate and Data Source", "url": "/posts/ios-delegate-and-data-source/", "categories": "technical-posts", "tags": "ios, view-controllers", "date": "2012-09-06 00:00:00 +0400", "snippet": "DelegatesDelegation design pattern is a way of modifying complex objects without sub classing them. Instead of sub classing, we use the complex object as it is and put any custom code for modifying the behaviour of that object inside a separate object, which is referred to as the Delegate Object.At predefined times, the complex object then calls the methods of the delegate object to give it a chance to run its custom code.Delegation is a simple and powerful pattern in which one object in a program acts on behalf of, or in coordination with, another object. The delegating object keeps a reference to the other objectóthe delegateóand at the appropriate time sends a message to it. The message informs the delegate of an event that the delegating object is about to handle or has just handled. The delegate may respond to the message by updating the appearance or state of itself or other objects in the application, and in some cases it can return a value that affects how an impending event is handled. The main value of delegation is that it allows you to easily customize the behavior of several objects in one central object.Delegation and the Cocoa FrameworksThe delegating object is typically a framework object, and the delegate is typically a custom controller object. The delegating object holds a weak reference to its delegate. Examples of delegation abound in the Foundation, UIKit, AppKit, and other Cocoa and Cocoa Touch frameworks. An example of a delegating object is an instance of the NSWindow class of the AppKit framework. NSWindow declares a protocol, among whose methods is windowShouldClose:. When a user clicks the close box in a window, the window object sends windowShouldClose: to its delegate to ask it to confirm the closure of the window. The delegate returns a Boolean value, thereby controlling the behavior of the window object.Delegation and NotificationsThe delegate of most Cocoa framework classes is automatically registered as an observer of notifications posted by the delegating object. The delegate need only implement a notification method declared by the framework class to receive a particular notification message. Following the example above, a window object posts an NSWindowWillCloseNotification to observers but sends a windowShouldClose: message to its delegate.Data SourceA data source is almost identical to a delegate. The difference is in the relationship with the delegating object. Instead of being delegated control of the user interface, a data source is delegated control of data. The delegating object, typically a view object such as a table view, holds a reference to its data source and occasionally asks it for the data it should display. A data source, like a delegate, must adopt a protocol and implement at minimum the required methods of that protocol. Data sources are responsible for managing the memory of the model objects they give to the delegating view." }, { "title": "iOS Category", "url": "/posts/ios-category/", "categories": "technical-posts", "tags": "ios", "date": "2012-09-06 00:00:00 +0400", "snippet": "Benefits A way of sectioning code. Categories are used for better code organisation. Distribute the implementation of your own classes into separate source files—for example, you could group the methods of a large class into several categories and put each category in a different file. It can be used to add methods to classes for which you do not have the source code. You typically use a category to add methods to an existing class, such as one defined in the Cocoa frameworks. A category is a way to enhance an existing class, by adding additional functions to it. You use categories to define additional methods of an existing class—even one whose source code is unavailable to you—without subclassing.Other Benefit and it’s issueCategories can also be used to override methods the class inherits, again, providing an alternative to sub classing. An alternative to sub classing. It provides a means to add methods to a class. You can always access the overridden method using super.If the name of a method declared in a category is the same as a method in the original class, or a method in another category on the same class (or even a superclass), the behaviour is undefined as to which method implementation is used at runtime.References Apple Document: Customizing existing classes http://stackoverflow.com/a/9424016/559017 Properties in category: http://nshipster.com/associated-objects/Extending a class vs CategoryThe difference between this and extending a class is that when you extend a class, you can add additional functions, as well as variables. In a category, you can only add additional functions. The benefit of a category though is that you donít have to use the extended class to get the benefits of the added additional functions. All you have to do is include the header file of the category, and the additional functions of that class are available to you.Background Whenever we add some methods through category then it becomes a part of that class definition. The compiler will never synthesize a property declared in a named category. Categories are attached to the classes at runtime. (IMP)load and Category +load, it is used to do category specific setup like initializing static variables. It’s like +initialize. Magical part of Objective C runtime: If multiple category implement +load, then all implementations will run. No guarantees on order, and we should never call +load method by hand. Every +load will be called only once. You should never called super load.Declaration Defining a category is identical to defining the interface for a class with one small exception: We add a category name inside a set of parenthesis after the interface declaration. Naming conventions like ClassName+NewMethodName.h and .m You cannot add instance variables to a class through a category. A category must import the interface file for the class it extends.Naming ConventionA common naming convention is that the base file name of the category is the name of the class the category extends followed by “+” followed by the name of the category.Example 1@interface NSString (MyCatergory) - (void)doSomethingWithString; @end@implementation NSString (MyCatergory) - (void)doSomethingWithString{      // do something here with string } @endExample 2: Adding properties to Category@interface UITableView (Animation) @property (nonatomic, retain) NSNumber *duration; @end#import &amp;lt;objc/runtime.h&amp;gt; static char DURATION_IDENTIFER;@implementation UITableView (Animation) @dynamic duration; (void)setDuration:(NSNumber *)duration {     objc_setAssociatedObject(self, &amp;amp;DURATION_IDENTIFER, duration, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } (NSNumber*)duration {     return objc_getAssociatedObject(self, &amp;amp;DURATION_IDENTIFER); } @end" }, { "title": "Blocks", "url": "/posts/blocks/", "categories": "", "tags": "blocks, example-code, ios, ios-4-0, iphone", "date": "2012-08-29 00:00:00 +0400", "snippet": "Blocks are an extension to the C language and thus fully supported in Objective-C.There are two ways to use block: The most common way to use a block is to pass it to a method that in turn calls the block. Example: UIView animation block or array/dictionary enumeration block. Create a block variable and assign a block to it. Then call the block directly. Example: Here’s how to assign our block to a block variable called now: Only declaration -[sourcecode language=”objc”] void (^now)(void); [/sourcecode]The name of the block variable is always preceded by a ^ and in parentheses. Block variables have an associated type. In this case, the now variable can reference any block that returns no value (the first void) and takes no parameters (the void in parentheses). Our block conforms to this type, so we can safely assign it to the now variable.[sourcecode language=”objc”] /* * * * * Declaration with block - * (This will give you a warning of unused variable now.) */ void (^now)(void) = ^ { NSDate *date = [NSDate date]; NSLog(@”The date and time is %@”, date); };// Here’s how we call our block - (This will remove above warning.) now();[/sourcecode]Examples:[sourcecode language=”objc”]/* * * * * A Block variable declaration * This will give you a warning of unused variable now. */void (^example0)(void);/* A Block body declaration * This will give you a warning of expression result unused. * ^ = The caret introduces a block literal. * {}; = The curly braces enclose statements makes the body of block. */^ { NSLog(@”Current Date: %@”, [NSDate date]); };/* * * Example 1. - Simple Print * Block variable declaration with void return type and void (no) parameter * Block calling with no arguments */void (^example1)(void) = ^ { NSDate *date = [NSDate date]; NSLog(@”The date and time is %@”, date); };example1();// Example 2. - Note worthy print int x = 1; NSDate *date = [NSDate date]; void (^example2)(void) = ^ { NSLog(@”%d - %@”, x, date); };example2();sleep(5); date = [NSDate date]; x=2; example2();/* Example 3. Variable Prints * With one parameter and int return type */int (^triple)(int); triple = ^(int number) { return number * 3; };int result = triple(1); NSLog(@”1. result: %d”, result);/* * With two parameter and int return type */ int (^multiply)(int, int); multiply = ^(int x, int y) { return x * y; };result = multiply(2, 3); NSLog(@”2. result: %d”, result);[/sourcecode]Instead of using raw types, I have typedef’d the blocks to simplify it. My experience is that it hurts really badly to not use type definitions, and sometimes it becomes so complicated that it won’t even compile. Just like with function pointers, always define block types to simplify your code.[sourcecode language=”objc”]/* * Example 4. Using typedef */typedef void (^JSVoidBlock)();typedef NSString* (^blockNameWithType) (double val); blockNameWithType testOne; //    _strProperty = [@”zeeshan” uppercaseString]; strInstanceVar = [@”zeeshan” uppercaseString];testOne = ^ (double newVal){ //        NSLog(@”Old val : %@”, strInstanceVar); //        _strProperty = [@”khan” uppercaseString]; strInstanceVar = [@”khan” uppercaseString]; return @”Block return value”; }; NSLog(@”Block val: %@”, testOne(23.0));[/sourcecode]Important Notes: The block takes a (read-only) snapshot of all the variables in scope that the block uses. The block variable looks like a function pointer and calling the block is similar to calling a function. But unlike function pointers, blocks are actually Objective-C objects. And that means we can pass them around like other objects. The block that is returned by some function is copied, and then autoreleased. This is because blocks begin life on the stack, and not on the heap. If the block is not copied onto the heap, it will be lost once it is out of scope; if it is not autoreleased, it will be leaked, for UIBarButtonItem retains a copy of the block as an associated object. We can use local variable inside the block, but that variable would be READ ONLY until we add __block in front of that variable declaration. BOOL with blocks (BOOL *stops): Boolean is actually a BOOL Star because it a kind of an outgoing argument, that is going to pass you all the keys and values in this dictionary one at time in the block. Block keeps the strong pointer to objects referenced inside of them. (those are used inside the block).Issue with Blocks:Memory Cycle - the only Problem with using block:[sourcecode language=”objc”] /* * Using a property */@property (non atomic, strong) NSArray *myBlocks; [self.myBlocks addObject:^(){ [self doSomething]; }];[/sourcecode]In this case, self is an object referenced in this block. Thus the block will have a strong point to self.But notice that self also has a strong pointer to the block through its myBlocks property.So, Neither self not the block can ever escape the heap now.That’s because there will always be a strong pointer to both of them (each other’s pointer).This is called a Memory Cycle.How to solve:- Use __Weak MyClass *weakSelf = self;" }, { "title": "Automatic Reference Counting - ARC", "url": "/posts/arc/", "categories": "", "tags": "", "date": "2012-08-29 00:00:00 +0400", "snippet": "ARC is supported in Xcode 4.2 and later OS X v10.6 and later (64-bit applications) and for iOS 4 and later. Weak references are not supported in OS X v10.6 and iOS 4. There is no ARC support in Xcode 4.1 and earlier.ARC is a compiler feature, so followings: Its a COMPILE TIME memory management model. Its NOT A RUN TIME memory management model. Compiler adds retain, release and autorelease calls to our code at Compile time. Its not new memory model, no new memory mechanism, Its just do retain and release automatically. Compiler adds C functions for retain and release, it does not call retain and release methods. It calls below methods objc_retain(someValue); objc_release(someValue); objc_autorelease(someValue); Compiler also generates appropriate dealloc method for us if needed. Automates Objective-C objects only (i.e. NSObject based objects). Neither it automates malloc() and free() nor CoreFoundation() and CoreGraphics() etc. That means we have to use CFRetain, CFRelease as MRC (Manual Reference Counting) for other than NSObjects classes. There are three places which we can not consider for ARC and a user has to manage memory manually with retain and release (MRC): No heap scan for unused objects (Its not Garbage Collector). No whole app pauses. No non-deterministic release.  Ownership Type Qualifiers __strong = An object remains “alive” as long as there is a strong pointer to it. Retain their values. Its default attribute of a property so we never have to type it. Stack local variables, method parameters are __strong.   __weak = only available on iOS 5 and Mac OX 10.7. Specifies a reference that does not keep the referenced object alive. A weak reference is set to nil when there are no strong references to the object. Don’t retain their values. Safely yield nil as soon as referenced object starts deallocating. NSWindow, NSViewController etc does not allow __weak references__weak id obj = [NSObject new]; *** means ***__weak id obj;id temp = [NSObject new];obj = id;[id release]; We can modified out Non-ARC code if we want to use __weak with below C functions objc_loadWeak(&amp;amp;myWeakIvar); objc_storeWeak(&amp;amp;myWeakIvar, newValue);  __unsafe_unretained = specifies a reference that does not keep the referenced object alive and is not set to nil when there are no strong references to the object. If the object it references is deallocated, the pointer is left dangling. An alternative for __weak, aka assign kind of property. __autoreleasing = is used to denote arguments that are passed by reference (id *) and are autoreleased on return. for indirect pointers which are treated like autoreleased return values  Correct Way to declare variable - *** ClassName * qualifier variableName; *** MyClass * __weak myWeakReference; MyClass * __unsafe_unretained myUnsafeReference; In some cases you can use __unsafe_unretained if the class isn’t __weak compatible. This can, however, become impractical for nontrivial cycles because it can be hard or impossible to validate that the __unsafe_unretained pointer is still valid and still points to the same object in question.ARC &amp;amp; Blocks Blocks work best under ARC! Blocks always start out on the stack, must be copied when: Stored into instance variables or globals. Returned or indirectly assigned In ARC blocks are automatically copied, we don’t need to copy a block to retain it in heap. __block objects variables are __strong by default under ARC.__block objects variables are __unsafe_unretained by default under non-ARC. (Dangling Pointer) Issue with ARC: You CAN NOT give an accessor a name that begins with new. This in turn means that you can’t, for example, declare a property whose name begins with new unless you specify a different getter: Won’t work: @property NSString *newTitle; Works: @property (getter=theNewTitle) NSString *newTitle;  Problem: Under ARC we may have issues with its strong reference behavior. Solution: we can convert objects into weak reference. 1. Either: __weak id objectName = self. 2. Or: __block __unsafe_unretained id objectName = self.   The following is invalid in ARC init methods: [super init]; The simple fix is to change it to: self = [super init]; The proper fix is to do that, and check the result for nil before continuing: self = [super init]; if (self) { …  Some Other Points: Using ARC, strong, weak, and autoreleasing stack variables are now implicitly initialized with nil. The new @autoreleasepool{} construct is about six times faster than NSAutoreleasePool object. @autoreleasepool{} even works in non-ARC code. Use Objective-C objects instead of structs. This is considered to be best practice anyway. In ARC Object Pointers must be initialized with nil. With ARC, instance variables are strong references by default—assigning an object to an instance variable directly does extend the lifetime of the object. Some new CF APIs __bridge, __bridge_retain, __bridge_transfer. Objects are often leaked when exceptions are thrown. We can not explicitly invoke dealloc, or implement or invoke retain, release, autorelease or retainCount. The prohibition extends to using @selector(retain), @selector(release) and so on. Migrate your code to ARC Compile code with LLVM 3.0 Use “Convert to Objective-C ARC” command in Xcode Fix issue until everything compiles Analyze code and fix issues Use Compiler Flags to Enable and Disable ARCYou enable ARC using a new -fobjc-arc compiler flag. You can also choose to use ARC on a per-file basis if it’s more convenient for you to use manual reference counting for some files. For projects that employ ARC as the default approach, you can disable ARC for a specific file using a new -fno-objc-arc compiler flag for that file.Object Graph Cycle New Pointer - Zeroing Weak Pointer (References) Just like objects Non-retaining reference Drops to nil automatically  This does not transfer ownership. - (void)takeThisError:(NSError*)error; this means - (void)takeThisError:(__autoreleased NSError*)error; Passing ownership is possible by using __strong- (void)takeThisError:(__strong NSError*)error;" }, { "title": "Grand Central Dispatch (GCD)", "url": "/posts/gcd/", "categories": "", "tags": "blocks, gcd, ios", "date": "2012-08-08 00:00:00 +0400", "snippet": "Grand Central Dispatch: + Dispatch Queue: It’s an object which is a queue, and that queue contains n number of functions or blocks as their tasks. Library automatically creates different priority levels to execute these tasks.  It’s a C API, but not standard C API, Its apple’s mechanism. It’s a core multithreading API developed by Apple developers. It optimizes application support for devices with multicore processors. It’s an implementation of Task Parallelism based on the Thread Pool Pattern. It was released with OS X 10.6 and iOS 4.0 and above. library name:- libdispatch.dylib  GCD provides and manages FIFO queues. GCD queue is a set of Block objects. Blocks are executed on a pool of threads fully managed by the system. No guarantee is made on a task execution. Functions by Task dispatch_get_global_queue - Returns a well-known global CONCURRENT queue of a given priority level. dispatch_get_main_queue - Returns the SERIAL dispatch queue associated with the application’s MAIN THREAD. dispatch_queue_create - Creates a new dispatch queue to which blocks can be submitted. dispatch_get_current_queue - Returns the queue on which the currently executing block is running. dispatch_queue_get_label - Returns the label specified for the queue when the queue was created. dispatch_set_target_queue - Sets the target queue for the given object. dispatch_main - Executes blocks submitted to the main queue.  dispatch_async - Submits a block for asynchronous execution on a dispatch queue and returns immediately. dispatch_async_f - Submits an application-defined function for asynchronous execution on a dispatch queue and returns immediately. dispatch_sync - Submits a block object for execution on a dispatch queue and waits until that block completes. dispatch_sync_f - Submits an application-defined function for synchronous execution on a dispatch queue. dispatch_after - Enqueue a block for execution at the specified time. dispatch_after_f - Enqueues an application-defined function for execution at a specified time. dispatch_apply - Submits a block to a dispatch queue for multiple invocations. dispatch_apply_f - Submits an application-defined function to a dispatch queue for multiple invocations. dispatch_once - Executes a block object once and only once for the lifetime of an application. GCD offers three kinds of queues: Main:- Tasks execute serially on your application’s main thread. (The main queue is automatically created by the system and associated with your application’s main thread.) Concurrent:- Tasks are dequeued in FIFO order, but run concurrently and can finish in any order. Serial - Serial Queue can only run one task at a time in FIFO order. A client to library may also create any number of serial queues, which execute tasks in the order they are submitted. Managing Dispatch Objects - Dispatch objects must be manually retained and released and are not garbage collected. dispatch_debug - Programmatically logs debug information about a dispatch object. dispatch_get_context - Returns the application-defined context of an object. dispatch_release - Decrements the reference (retain) count of a dispatch object. dispatch_resume - Resume the invocation of block objects on a dispatch object. dispatch_retain - Increments the reference (retain) count of a dispatch object. dispatch_set_context - Associates an application-defined context with the object. dispatch_set_finalizer_f - Sets the finalizer function for a dispatch object. dispatch_suspend - Suspends the invocation of block objects on a dispatch object. Other  - TODO Dispatch Semaphores - Executes a certain number of blocks/functions concurrently. Dispatch Barriers Dispatch Sources - Executes blocks or functions asynchronously. Dispatch I/O Convenience API Dispatch I/O Channel API Dispatch Data Objects Managing Time and Dispatch Queue-Specific Context Data" }, { "title": "iPad Keyboard Notifications for Show/Hide, Split &amp;amp; Dock/Undock", "url": "/posts/ipad-keyboard-notifications/", "categories": "", "tags": "ios, ipad, keyboard-notification, split-keyboard", "date": "2012-08-03 00:00:00 +0400", "snippet": "If your app is using iOS 5.0 and above then this is a very good link:http://adevelopingstory.com/blog/2012/05/the-ipad-split-keyboard-and-missing-notifications.html" }, { "title": "Hide / Dismiss Present Model View Controller on iPad", "url": "/posts/hide-dismiss-present-model-view-controller-on-ipad/", "categories": "", "tags": "ios, ipad", "date": "2012-08-03 00:00:00 +0400", "snippet": "If Base view controller is a View Controller then override this method- (BOOL)disablesAutomaticKeyboardDismissal {    return NO;}Be careful if you are displaying the modal with a UINavigationController. You then have to set thedisablesAutomaticKeyboardDismissal on the navigation controller and not on the view controller. You can easily do this with categories.File: UINavigationController+KeyboardDismiss.h#import &amp;lt;Foundation/Foundation.h&amp;gt;@interface UINavigationController (KeyboardDismiss)- (BOOL)disablesAutomaticKeyboardDismissal;@endFile: UINavigationController+KeyboardDismiss.m#import &quot;UINavigationController+KeyboardDismiss.h&quot;@implementation UINavigationController(KeyboardDismiss)- (BOOL)disablesAutomaticKeyboardDismissal{    return NO;}@endDo not forget to import the category in the file where you use the UINavigationController.Related links:http://stackoverflow.com/questions/3372333/ipad-keyboard-will-not-dismiss-if-modal-view-controller-presentation-style-is-uihttp://stackoverflow.com/questions/3372333/ipad-keyboard-will-not-dismiss-if-modal-view-controller-presentation-style-is-ui" }, { "title": "Strong Vs Weak - ARC", "url": "/posts/strong-vs-weak-arc/", "categories": "technical-posts", "tags": "arc, ios, ios-5-0, strong, weak", "date": "2012-03-02 00:00:00 +0400", "snippet": "The difference is that an object will be deallocated as soon as there are no strong pointers to it. Even if weak pointers point to it, once the last strong pointer is gone, the object will be deallocated, and all remaining weak pointers will be zeroed out. Perhaps an example is in order.Imagine our object is a dog, and that the dog wants to run away (be deallocated).Strong pointers are like a leash on the dog. As long as you have the leash attached to the dog, the dog will not run away. If five people attach their leash to one dog, (five strong pointers to one object), then the dog will not run away until all five leashes are detached.Weak pointers, on the other hand, are like little kids pointing at the dog and saying “Look! A dog!” As long as the dog is still on the leash, the little kids can still see the dog, and they’ll still point to it. As soon as all the leashes are detached, though, the dog runs away no matter how many little kids are pointing to it. As soon as the last strong pointer (leash) no longer points to an object, the object will be deallocated, and all weak pointers will be zeroed out.‘Weak’ notes:In a property declaration, weak only applies to the synthesized setter method, if any, and synthesized instance variable, if any. If neither of those are synthesized then weak has no effect.If the setter and instance variable are synthesized, the question then is: which property declaration is the compiler using to synthesize the setter and instance variable?The compiler will never synthesize a property declared in a named category.Strong: A strong reference is a reference to an object that stops it from being deallocated. In other words it creates a owner relationship.  A class instance takes an ownership interest a referenced object (i.e. so it cannot be deallocated until the owner is).Weak: A weak reference is a reference to an object that does not stop it from being deallocated. In other words, it does not create an owner relationship. We do not “own” the object being referred to (e.g. typically a child object should not own its parent, so we would use a weak reference).SetupTo enable ARC simply set the Objective-C Automatic Reference Counting option in your Xcode project’s Build Settings to YES. Behind the scenes this sets the -fobjc-arc compiler flag that enables ARC.Project File -&amp;gt; Build Settings -&amp;gt; Settings -&amp;gt; Objective-C Automatic Reference Counting : toggled button is there.Notes: Automatic Reference Counting (ARC) is a compiler-level feature. We can use strong in iOS 4 too but we can not use weak in iOS 4. We must not make any retain/release/autorelease/retainCount/[super dealloc] calls. This is not Garbage Collection, and reference counted memory has not disappeared, it has simply been automated. ARC can be disabled on a file by file basis. @autoreleasepool{}blocks instead of NSAutoReleasePool We cannot use NSAllocateObject or NSDeallocateObject.Other References: Quora, and Another exampleThanks for reading :)" }, { "title": "Absolute &amp;amp; Relative Paths", "url": "/posts/difference-between-absolute-and-relative-paths/", "categories": "", "tags": "", "date": "2012-02-13 00:00:00 +0400", "snippet": "Absolute Paths Absolute paths are very specific paths that include the domain name. The absolute path can often be pasted directly in the address bar to access the web element directly (often the same as a URL).Example of an Absolute path You typically use the absolute path with the domain to point to Web elements that are on another domain than your own.It is a good idea to use absolute paths, without the domain name, on most Web sites. This format insures that the link or image will be usable no matter where you place the page. This may seem like a silly reason to use longer links, but if you share code across multiple pages and directories on your site, using absolute paths will speed up your maintenance.Relative Paths Relative paths are paths the are defined from the location of the current page. Some rules of creating a relative path: links in the same directory as the page have no path information listed: MyFile sub-directories are listed without any preceding slashes: Downloads/MyFile links up one directory are listed as: ../MyFileRelative paths are sometimes more difficult to work with as the path to a web element will change depending on the location of the current page.  The upside is that relative paths are alot shorter than absoltue paths and decrease the size of the resulting HTML code.In web or desktop programming/command-prompt use, we often come through such situations where we have to use relative/absolute paths. Is there are any differences between the notation “./” and “/” ?./Yes, there are! When you use “./” we mean an relative path. Suppose, you are in the location_http://www.somedomain.com/some_directory/index.html_Now, if you want to insert an Image file which is located at this directory “some_directory”, you can write following code in your index.html page:If you want to use an image from a directory “another_dir” on level up, you should use “../”Both some_dir and another_dir are located under the home of your domain (www.somedomain.com)./Now, let’s talk about using “/”“/” means beginning from the Root level of your file system. Suppose, in Linux, you want to Change your current working directory to the directory “etc”. Since “etc” is placed just in the Root directory of your file system (see the image below), you should type something like this in your command-prompt:cd /etcIf you tried with the command “cd ./etc”, it wouldn’t work! Why? Because “./” means beginning from the Current Working directory. Normally, when you use a command-prompt it selects the user’s Home folder as current working directory. So if you want to go to a directory based on root level, you should use “/” instead of “./”Image: Unix/Linux File System. See, the folder “etc” stays just below the “root” or “/”Absolute path contains full name of file including the source, for instance, c:\\Windows\\Temp\\log.txt. Relative path contains only the path relativaly to a certain folder, for instance, relative path of log.txt relativaly to the folder Windows is Temp\\log.txt.Read more: http://wiki.answers.com/Q/What_is_the_difference_between_relative_path_and_absolute_path#ixzz1mEyM6iBX" }, { "title": "eCommerce Support for iPhone and Web", "url": "/posts/ecommerce-support-for-iphone-and-web/", "categories": "", "tags": "ecommerce-stores, inventory", "date": "2012-02-02 00:00:00 +0400", "snippet": "Hi All, Today i was looking for some eCommerce support for iPhone and Web both, and i have found a useful tool.+ Magento: - It is an open source tool to create an online shopping portal.+ Magento API: - Magento provides the Core API support to manage eCommerce stores. - Basically, The set of Core APIs are used to manage custom resources like customer, products, sales orders, shopping carts and inventory. - These APIs supports SOAP and XML-RPC protocols.+ Reference: - http://www.magentocommerce.com - http://www.magentocommerce.com/support/magento_core_api" }, { "title": "Open source libraries for iOS", "url": "/posts/open-source-libraries-for-ios/", "categories": "", "tags": "frameworks, ios-library", "date": "2012-02-01 00:00:00 +0400", "snippet": "I have found some useful iOS libraries. Three20 : Framework developed by Facebook for their iPhone App. MBProgressHUD : To display a progress activity window. DSActivityView: To display a progress activity window. CorePlot : To draw colorful graphics. TISwipeableTableView : Swappable Cell to display a menu, like the Twitter or Facebook Apps. MGTwitter : A custom Twitter engine. Cocoa / Cocoa Touch Controls: Offers a great selection of open source controllers and libraries. iOS Frameworks : Offers a great selection of open source controllers and libraries. ASIHTTPRequest : For everything related to web-stuff. EGOTableViewPullRefresh : Pull to refresh library. SFHFKeychainUtils : If you are working with passwords. GDataXML : Helped me a lot with parsing XML files. More on this" }, { "title": "iOS Mirroring", "url": "/posts/ios-mirroring/", "categories": "", "tags": "ios-mirroring, iphone-projector", "date": "2012-02-01 00:00:00 +0400", "snippet": "Requirement: ——————— The prospect is trying to create an iOS app which will MIRROR the iPhone, iPad content using the pico projector and also be able to control the projector ( on the projector, increase volume etc). Can you please get a feasibility check done if this is possible and if so how.Client is looking to create an iOS application for PICO projectors. Refer http://www.brookstone.com/pocket-projector-for-iphone-4Requirement Highlights: ————————————— 1. Mirror the iPhone, iPad content using the pico projector. 2. Control the projector ( on the projector, increase volume etc).Findings for solution/feasibility ———————————————— To mirror iPhone screen: Jailbreaked iOS and use Veency, iDemo or screensplitr http://www.youtube.com/watch?v=wjPZzCZWxAITo output to external device from your application: Implement External Display Support in your app in iOS 3.2, 4.0External Display Support - Introduced in iOS 3.2 (Supports iPhone/iPod touch from iOS 4.0) ————————————— http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Articles/iPhoneOS3_2.htmlIn iOS 3.2 we have UIScreen class object that provides support for retrieving screen objects for external display through a set of supported cables.Windows (represented by the UIWindow class) can now be assigned to a specific screen.Apple VGA Adapter - (It has limitations, read reviews) ————————————— http://store.apple.com/us/product/MC552ZM/B#overviewAirPlay - Introduced with iOS 4.2 ———— AirPlay is a technology that lets your application stream AUDIO to Apple TV and to third-party AirPlay speakers and receivers.AirPlay Video Support - iOS 4.3 ——————————— This support allows you to play video-based content on AirPlay–enabled hardware such as Apple TV.AirPlay Improvements - iOS 5.0 ——————————— AirPlay lets users stream audio and video from an iOS-based device to AirPlay–enabled devices such as televisions and audio systems.Note: In iOS 5, AirPlay is enabled by default for all objects that support it. If you do not want your application’s content to be playable over AirPlay, you must opt out explicitly.iOS: About Apple AV Adapter compatibility ————————————— http://support.apple.com/kb/ht4108Stack Overflow: ———————— http://stackoverflow.com/questions/3289147/possible-to-mirror-iphone-ipad-screen-on-a-monitor-without-jailbreakingAvailable External Device: ————————————— Optima Pocket Projecthttp://www.optoma.co.uk/picoconsumer.aspx?PC=PK120&amp;amp;ShowMenu=Y&amp;amp;PTypeDB=Picohttp://www.optoma.co.uk/picoconsumer.aspx?PC=PK201&amp;amp;ShowMenu=Y&amp;amp;PTypeDB=PicoApple store link: http://store.apple.com/us/product/H1713ZM/A1. http://www.youtube.com/watch?v=fROxb6WdsS0 2. http://www.youtube.com/watch?v=_kO-pN5CcfsApple Q/A link: http://store.apple.com/us/questions/product/H1713ZM/Ahttp://www.core77.com/blog/videos/optoma_pico_pocket_projector_for_iphoneipod_live_at_the_apple_store_today_13655.aspOther Videos and link: ———————————http://picoprojector.org/projectors/optoma-pk102/Pocket Projector: http://www.youtube.com/watch?v=vqqxB_r7VoQ Store: http://store.apple.com/us/product/H1713ZM/A Queries: http://store.apple.com/us/questions/product/H1713ZM/AMini Projector: http://www.youtube.com/watch?v=bqRfNq-qydc&amp;amp;feature=relatedhttp://www.youtube.com/watch?v=uNm3Fe6AJX8&amp;amp;feature=BFa&amp;amp;list=ULliMqQmpgSKY&amp;amp;lf=mfu_in_orderhttp://www.youtube.com/watch?v=wjPZzCZWxAIRelease note of all the iOS ——————————————— http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Introduction/Introduction.htmlSome code stuff —————————— http://blog.appideas.net/using-iphone-video-output-to-demo-your-apps-o" }, { "title": "Hidden Features of Xcode 4", "url": "/posts/hidden-features-of-xcode-4/", "categories": "", "tags": "shortcuts, xcode", "date": "2012-01-31 00:00:00 +0400", "snippet": "Hi All, I was exploring Xcode 4 features and i found some pretty stuff to share. Below is the list of Xcode features which may help you with writing Cocoa/Cocoa touch code. You can find the discussion on Stack Over Flow.1. Pragma mark: It provides nice visual grouping in the Xcode class dropdown list. More on PragmaSyntax: #pragma mark - 2. You can double-click tabs in Xcode 4 to rename them, then use named tabs in Prefs &amp;gt; Behaviors3. Some useful short cuts: cmd-0 to hide the Navigator Pane on left. cmd-[1..n] switch between Navigators Pane on left. cmd-opt-0 to hide the Utilities Pane on right. cmd-opt-[1..n] switch between Utilities Pane on right. cmd-shift-y to show/hide Debug area on bottom. cmd-shift-1 to open Welcome page of Xcode. cmd-shift-2 to open the Organizer window. shift-cmd-opt click on a symbol lets you tell Xcode exactly where in the UI you want the navigated-to file to open. ctrl-6 pops down within-file segment of jump bar (enables keyboard-controlled jump to methods) cmd-{/} select previous / next tab cmd-J navigate to any editor (but why oh why doesn’t TAB then cycle between them?)Editor ShortCuts Cmd + Ctrl + up/down Jump between .h &amp;amp; .m Files. Cmd + Ctrl + Left/Right Jump between Previous Edited Files/Next Edited files.Layout Shortcuts Cmd + 0 hide or show navigators Cmd + opt + 0 hide or show inspectors Cmd + Shift + Y hide or show debugger console.Navigators Shortcuts Cmd + 1 Project Cmd + 2 Symbol Cmd + 3 Search Cmd + 4 Issue Cmd + 5 Debug Cmd + 6 BreakPoint Cmd + 7 LogTab Switching &amp;amp; Jumping Cmd + { Previous Tab Cmd + } Next Tab Cmd + j Select location to jump Shift + Option + ClickFile Select location to open file Cmd + Alt + Option + Click Select location to open MethodInspectors Cmd + Opt + 1 File Inspector Cmd + Opt + 2 Quick Help Cmd + Opt + 3 Identity Inspector Cmd + Opt + 4 Attribute Inspector Cmd + Opt + 5 Size inspector Cmd + Opt + 6 Connection InspectorBuild Related Cmd + B Build Cmd + Shift + K Clean Cmd + . topCode Folding Cmd + Alt + Left Minimize Current Method/Class/Interface Cmd + Alt + Right Expand Current Method/Class/Interface Cmd + Alt + Shift + Left Minimize All Method/Class/Interface Cmd + Alt + Shift + Right Expand All Method/Class/Interface" }, { "title": "Best practices for writing Objective-C code", "url": "/posts/best-practices-for-writing-objective-c-code/", "categories": "", "tags": "cocoa-best-practices, objective-c", "date": "2012-01-31 00:00:00 +0400", "snippet": "I have found some best practices for writing Objective C code. More on the same1) With the advent of properties, I no longer use “_” to prefix “private” class variables. After all, if a variable can be accessed by other classes shouldn’t there be a property for it? I always disliked the “_” prefix for making code uglier, and now I can leave it out.2) Speaking of private things, I prefer to place private method definitions within the .m file in a class extension like so:#import &quot;MyClass.h&quot; @interface MyClass () - (void) someMethod - (void) someOtherMethod @end @implementation MyClass Why clutter up the .h file with things outsiders should not care about? The empty () works for private categories in the .m file, and issues compile warnings if you do not implement the methods declared.3) I have taken to putting dealloc at the top of the .m file, just below the @synthesize directives. Shouldn’t what you dealloc be at the top of the list of things you want to think about in a class? That is especially true in an environment like the iPhone.3.5) In table cells, make every element (including the cell itself) opaque for performance. That means setting the appropriate background color in everything.3.6) When using an NSURLConnection, as a rule you may well want to implement the delegate method:- (NSCachedURLResponse *)connection:(NSURLConnection *)connection                  willCacheResponse:(NSCachedURLResponse *)cachedResponse {       return nil; } I find most web calls are very singular and it’s more the exception than the rule you’ll be wanting responses cached, especially for web service calls. Implementing the method as shown disables caching of responses.Also of interest, are some good iPhone specific tips from Joseph Mattiello (received in an iPhone mailing list). There are more, but these were the most generally useful I thought (note that a few bits have now been slightly edited from the original to include details offered in responses):4) Only use double precision if you have to, such as when working with CoreLocation. Make sure you end your constants in ‘f’ to make gcc store them as floats.float val = someFloat * 2.2f; This is mostly important when someFloat may actually be a double, you don’t need the mixed-mode math, since you’re losing precision in ‘val’ on storage. While floating-point numbers are supported in hardware on iPhones, it may still take more time to do double-precision arithmetic as opposed to single precision. References: Double vs float on the iPhone iPhone/iPad double precision mathOn the older phones supposedly calculations operate at the same speed but you can have more single precision components in registers than doubles, so for many calculations single precision will end up being faster.5) Set your properties as nonatomic. They’re atomic by default and upon synthesis, semaphore code will be created to prevent multi-threading problems. 99% of you probably don’t need to worry about this and the code is much less bloated and memory efficient when set to nonatomic.6) SQLite can be a very, very fast way to cache large data sets. A map application for instance can cache its tiles into SQLite files. The most expensive part is disk I/O. Avoid many small writes by sending BEGIN; andCOMMIT; between large blocks. We use a 2 second timer for instance that resets on each new submit. When it expires, we send COMMIT; , which causes all your writes to go in one large chunk. SQLite stores transaction data to disk and doing this Begin/End wrapping avoids creation of many transaction files, grouping all of the transactions into one file.Also, SQL will block your GUI if it’s on your main thread. If you have a very long query, It’s a good idea to store your queries as static objects, and run your SQL on a separate thread. Make sure to wrap anything that modifies the database for query strings in @synchronize() {} blocks. For short queries just leave things on the main thread for easier convenience." } ]
